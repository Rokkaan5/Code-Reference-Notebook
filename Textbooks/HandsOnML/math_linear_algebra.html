<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.2.269">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Math - Linear Algebra</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="math_linear_algebra_files/libs/clipboard/clipboard.min.js"></script>
<script src="math_linear_algebra_files/libs/quarto-html/quarto.js"></script>
<script src="math_linear_algebra_files/libs/quarto-html/popper.min.js"></script>
<script src="math_linear_algebra_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="math_linear_algebra_files/libs/quarto-html/anchor.min.js"></script>
<link href="math_linear_algebra_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="math_linear_algebra_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="math_linear_algebra_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="math_linear_algebra_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="math_linear_algebra_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#vectors" id="toc-vectors" class="nav-link active" data-scroll-target="#vectors">Vectors</a>
  <ul class="collapse">
  <li><a href="#definition" id="toc-definition" class="nav-link" data-scroll-target="#definition">Definition</a></li>
  <li><a href="#purpose" id="toc-purpose" class="nav-link" data-scroll-target="#purpose">Purpose</a></li>
  <li><a href="#vectors-in-python" id="toc-vectors-in-python" class="nav-link" data-scroll-target="#vectors-in-python">Vectors in python</a></li>
  <li><a href="#plotting-vectors" id="toc-plotting-vectors" class="nav-link" data-scroll-target="#plotting-vectors">Plotting vectors</a>
  <ul class="collapse">
  <li><a href="#d-vectors" id="toc-d-vectors" class="nav-link" data-scroll-target="#d-vectors">2D vectors</a></li>
  <li><a href="#d-vectors-1" id="toc-d-vectors-1" class="nav-link" data-scroll-target="#d-vectors-1">3D vectors</a></li>
  </ul></li>
  <li><a href="#norm" id="toc-norm" class="nav-link" data-scroll-target="#norm">Norm</a></li>
  <li><a href="#addition" id="toc-addition" class="nav-link" data-scroll-target="#addition">Addition</a></li>
  <li><a href="#multiplication-by-a-scalar" id="toc-multiplication-by-a-scalar" class="nav-link" data-scroll-target="#multiplication-by-a-scalar">Multiplication by a scalar</a></li>
  <li><a href="#zero-unit-and-normalized-vectors" id="toc-zero-unit-and-normalized-vectors" class="nav-link" data-scroll-target="#zero-unit-and-normalized-vectors">Zero, unit and normalized vectors</a></li>
  <li><a href="#dot-product" id="toc-dot-product" class="nav-link" data-scroll-target="#dot-product">Dot product</a>
  <ul class="collapse">
  <li><a href="#definition-1" id="toc-definition-1" class="nav-link" data-scroll-target="#definition-1">Definition</a></li>
  <li><a href="#in-python" id="toc-in-python" class="nav-link" data-scroll-target="#in-python">In python</a></li>
  <li><a href="#main-properties" id="toc-main-properties" class="nav-link" data-scroll-target="#main-properties">Main properties</a></li>
  <li><a href="#calculating-the-angle-between-vectors" id="toc-calculating-the-angle-between-vectors" class="nav-link" data-scroll-target="#calculating-the-angle-between-vectors">Calculating the angle between vectors</a></li>
  <li><a href="#projecting-a-point-onto-an-axis" id="toc-projecting-a-point-onto-an-axis" class="nav-link" data-scroll-target="#projecting-a-point-onto-an-axis">Projecting a point onto an axis</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#matrices" id="toc-matrices" class="nav-link" data-scroll-target="#matrices">Matrices</a>
  <ul class="collapse">
  <li><a href="#matrices-in-python" id="toc-matrices-in-python" class="nav-link" data-scroll-target="#matrices-in-python">Matrices in python</a></li>
  <li><a href="#size" id="toc-size" class="nav-link" data-scroll-target="#size">Size</a></li>
  <li><a href="#element-indexing" id="toc-element-indexing" class="nav-link" data-scroll-target="#element-indexing">Element indexing</a></li>
  <li><a href="#square-triangular-diagonal-and-identity-matrices" id="toc-square-triangular-diagonal-and-identity-matrices" class="nav-link" data-scroll-target="#square-triangular-diagonal-and-identity-matrices">Square, triangular, diagonal and identity matrices</a></li>
  <li><a href="#adding-matrices" id="toc-adding-matrices" class="nav-link" data-scroll-target="#adding-matrices">Adding matrices</a></li>
  <li><a href="#scalar-multiplication" id="toc-scalar-multiplication" class="nav-link" data-scroll-target="#scalar-multiplication">Scalar multiplication</a></li>
  <li><a href="#matrix-multiplication" id="toc-matrix-multiplication" class="nav-link" data-scroll-target="#matrix-multiplication">Matrix multiplication</a></li>
  <li><a href="#matrix-transpose" id="toc-matrix-transpose" class="nav-link" data-scroll-target="#matrix-transpose">Matrix transpose</a></li>
  <li><a href="#converting-1d-arrays-to-2d-arrays-in-numpy" id="toc-converting-1d-arrays-to-2d-arrays-in-numpy" class="nav-link" data-scroll-target="#converting-1d-arrays-to-2d-arrays-in-numpy">Converting 1D arrays to 2D arrays in NumPy</a></li>
  <li><a href="#plotting-a-matrix" id="toc-plotting-a-matrix" class="nav-link" data-scroll-target="#plotting-a-matrix">Plotting a matrix</a></li>
  <li><a href="#geometric-applications-of-matrix-operations" id="toc-geometric-applications-of-matrix-operations" class="nav-link" data-scroll-target="#geometric-applications-of-matrix-operations">Geometric applications of matrix operations</a>
  <ul class="collapse">
  <li><a href="#addition-multiple-geometric-translations" id="toc-addition-multiple-geometric-translations" class="nav-link" data-scroll-target="#addition-multiple-geometric-translations">Addition = multiple geometric translations</a></li>
  <li><a href="#scalar-multiplication-1" id="toc-scalar-multiplication-1" class="nav-link" data-scroll-target="#scalar-multiplication-1">Scalar multiplication</a></li>
  <li><a href="#matrix-multiplication-projection-onto-an-axis" id="toc-matrix-multiplication-projection-onto-an-axis" class="nav-link" data-scroll-target="#matrix-multiplication-projection-onto-an-axis">Matrix multiplication – Projection onto an axis</a></li>
  <li><a href="#matrix-multiplication-rotation" id="toc-matrix-multiplication-rotation" class="nav-link" data-scroll-target="#matrix-multiplication-rotation">Matrix multiplication – Rotation</a></li>
  <li><a href="#matrix-multiplication-other-linear-transformations" id="toc-matrix-multiplication-other-linear-transformations" class="nav-link" data-scroll-target="#matrix-multiplication-other-linear-transformations">Matrix multiplication – Other linear transformations</a></li>
  </ul></li>
  <li><a href="#matrix-inverse" id="toc-matrix-inverse" class="nav-link" data-scroll-target="#matrix-inverse">Matrix inverse</a></li>
  <li><a href="#determinant" id="toc-determinant" class="nav-link" data-scroll-target="#determinant">Determinant</a></li>
  <li><a href="#composing-linear-transformations" id="toc-composing-linear-transformations" class="nav-link" data-scroll-target="#composing-linear-transformations">Composing linear transformations</a></li>
  <li><a href="#singular-value-decomposition" id="toc-singular-value-decomposition" class="nav-link" data-scroll-target="#singular-value-decomposition">Singular Value Decomposition</a></li>
  <li><a href="#eigenvectors-and-eigenvalues" id="toc-eigenvectors-and-eigenvalues" class="nav-link" data-scroll-target="#eigenvectors-and-eigenvalues">Eigenvectors and eigenvalues</a></li>
  <li><a href="#trace" id="toc-trace" class="nav-link" data-scroll-target="#trace">Trace</a></li>
  </ul></li>
  <li><a href="#what-next" id="toc-what-next" class="nav-link" data-scroll-target="#what-next">What next?</a></li>
  </ul>
</nav>
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Math - Linear Algebra</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<p><em>Linear Algebra is the branch of mathematics that studies <a href="https://en.wikipedia.org/wiki/Vector_space">vector spaces</a> and linear transformations between vector spaces, such as rotating a shape, scaling it up or down, translating it (ie. moving it), etc.</em></p>
<p><em>Machine Learning relies heavily on Linear Algebra, so it is essential to understand what vectors and matrices are, what operations you can perform with them, and how they can be useful.</em></p>
<section id="vectors" class="level1">
<h1>Vectors</h1>
<section id="definition" class="level2">
<h2 class="anchored" data-anchor-id="definition">Definition</h2>
<p>A vector is a quantity defined by a magnitude and a direction. For example, a rocket’s velocity is a 3-dimensional vector: its magnitude is the speed of the rocket, and its direction is (hopefully) up. A vector can be represented by an array of numbers called <em>scalars</em>. Each scalar corresponds to the magnitude of the vector with regards to each dimension.</p>
<p>For example, say the rocket is going up at a slight angle: it has a vertical speed of 5,000&nbsp;m/s, and also a slight speed towards the East at 10 m/s, and a slight speed towards the North at 50 m/s. The rocket’s velocity may be represented by the following vector:</p>
<p><strong>velocity</strong> <span class="math inline">\(= \begin{pmatrix} 10 \\ 50 \\ 5000 \\ \end{pmatrix}\)</span></p>
<p>Note: by convention vectors are generally presented in the form of columns. Also, vector names are generally lowercase to distinguish them from matrices (which we will discuss below) and in bold (when possible) to distinguish them from simple scalar values such as <span class="math inline">\({meters\_per\_second} = 5026\)</span>.</p>
<p>A list of N numbers may also represent the coordinates of a point in an N-dimensional space, so it is quite frequent to represent vectors as simple points instead of arrows. A vector with 1 element may be represented as an arrow or a point on an axis, a vector with 2 elements is an arrow or a point on a plane, a vector with 3 elements is an arrow or point in space, and a vector with N elements is an arrow or a point in an N-dimensional space… which most people find hard to imagine.</p>
</section>
<section id="purpose" class="level2">
<h2 class="anchored" data-anchor-id="purpose">Purpose</h2>
<p>Vectors have many purposes in Machine Learning, most notably to represent observations and predictions. For example, say we built a Machine Learning system to classify videos into 3 categories (good, spam, clickbait) based on what we know about them. For each video, we would have a vector representing what we know about it, such as:</p>
<p><strong>video</strong> <span class="math inline">\(= \begin{pmatrix} 10.5 \\ 5.2 \\ 3.25 \\ 7.0 \end{pmatrix}\)</span></p>
<p>This vector could represent a video that lasts 10.5 minutes, but only 5.2% viewers watch for more than a minute, it gets 3.25 views per day on average, and it was flagged 7 times as spam. As you can see, each axis may have a different meaning.</p>
<p>Based on this vector our Machine Learning system may predict that there is an 80% probability that it is a spam video, 18% that it is clickbait, and 2% that it is a good video. This could be represented as the following vector:</p>
<p><strong>class_probabilities</strong> <span class="math inline">\(= \begin{pmatrix} 0.80 \\ 0.18 \\ 0.02 \end{pmatrix}\)</span></p>
</section>
<section id="vectors-in-python" class="level2">
<h2 class="anchored" data-anchor-id="vectors-in-python">Vectors in python</h2>
<p>In python, a vector can be represented in many ways, the simplest being a regular python list of numbers:</p>
<div class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>[<span class="fl">10.5</span>, <span class="fl">5.2</span>, <span class="fl">3.25</span>, <span class="fl">7.0</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="2">
<pre><code>[10.5, 5.2, 3.25, 7.0]</code></pre>
</div>
</div>
<p>Since we plan to do quite a lot of scientific calculations, it is much better to use NumPy’s <code>ndarray</code>, which provides a lot of convenient and optimized implementations of essential mathematical operations on vectors (for more details about NumPy, check out the <a href="tools_numpy.ipynb">NumPy tutorial</a>). For example:</p>
<div class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>video <span class="op">=</span> np.array([<span class="fl">10.5</span>, <span class="fl">5.2</span>, <span class="fl">3.25</span>, <span class="fl">7.0</span>])</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>video</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="3">
<pre><code>array([ 10.5 ,   5.2 ,   3.25,   7.  ])</code></pre>
</div>
</div>
<p>The size of a vector can be obtained using the <code>size</code> attribute:</p>
<div class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>video.size</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="4">
<pre><code>4</code></pre>
</div>
</div>
<p>The <span class="math inline">\(i^{th}\)</span> element (also called <em>entry</em> or <em>item</em>) of a vector <span class="math inline">\(\textbf{v}\)</span> is noted <span class="math inline">\(\textbf{v}_i\)</span>.</p>
<p>Note that indices in mathematics generally start at 1, but in programming they usually start at 0. So to access <span class="math inline">\(\textbf{video}_3\)</span> programmatically, we would write:</p>
<div class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>video[<span class="dv">2</span>]  <span class="co"># 3rd element</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="5">
<pre><code>3.25</code></pre>
</div>
</div>
</section>
<section id="plotting-vectors" class="level2">
<h2 class="anchored" data-anchor-id="plotting-vectors">Plotting vectors</h2>
<p>To plot vectors we will use matplotlib, so let’s start by importing it (for details about matplotlib, check the <a href="tools_matplotlib.ipynb">matplotlib tutorial</a>):</p>
<div class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>matplotlib inline</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<section id="d-vectors" class="level3">
<h3 class="anchored" data-anchor-id="d-vectors">2D vectors</h3>
<p>Let’s create a couple very simple 2D vectors to plot:</p>
<div class="cell" data-jupyter="{&quot;outputs_hidden&quot;:true}" data-execution_count="7">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>u <span class="op">=</span> np.array([<span class="dv">2</span>, <span class="dv">5</span>])</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>v <span class="op">=</span> np.array([<span class="dv">3</span>, <span class="dv">1</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>These vectors each have 2 elements, so they can easily be represented graphically on a 2D graph, for example as points:</p>
<div class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>x_coords, y_coords <span class="op">=</span> <span class="bu">zip</span>(u, v)</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>plt.scatter(x_coords, y_coords, color<span class="op">=</span>[<span class="st">"r"</span>,<span class="st">"b"</span>])</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>plt.axis([<span class="dv">0</span>, <span class="dv">9</span>, <span class="dv">0</span>, <span class="dv">6</span>])</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>plt.grid()</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="math_linear_algebra_files/figure-html/cell-8-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>Vectors can also be represented as arrows. Let’s create a small convenience function to draw nice arrows:</p>
<div class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> plot_vector2d(vector2d, origin<span class="op">=</span>[<span class="dv">0</span>, <span class="dv">0</span>], <span class="op">**</span>options):</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> plt.arrow(origin[<span class="dv">0</span>], origin[<span class="dv">1</span>], vector2d[<span class="dv">0</span>], vector2d[<span class="dv">1</span>],</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>              head_width<span class="op">=</span><span class="fl">0.2</span>, head_length<span class="op">=</span><span class="fl">0.3</span>, length_includes_head<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>              <span class="op">**</span>options)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now let’s draw the vectors <strong>u</strong> and <strong>v</strong> as arrows:</p>
<div class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>plot_vector2d(u, color<span class="op">=</span><span class="st">"r"</span>)</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>plot_vector2d(v, color<span class="op">=</span><span class="st">"b"</span>)</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>plt.axis([<span class="dv">0</span>, <span class="dv">9</span>, <span class="dv">0</span>, <span class="dv">6</span>])</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>plt.grid()</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="math_linear_algebra_files/figure-html/cell-10-output-1.png" class="img-fluid"></p>
</div>
</div>
</section>
<section id="d-vectors-1" class="level3">
<h3 class="anchored" data-anchor-id="d-vectors-1">3D vectors</h3>
<p>Plotting 3D vectors is also relatively straightforward. First let’s create two 3D vectors:</p>
<div class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> np.array([<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">8</span>])</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> np.array([<span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">3</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now let’s plot them using matplotlib’s <code>Axes3D</code>:</p>
<div class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> mpl_toolkits.mplot3d <span class="im">import</span> Axes3D</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>subplot3d <span class="op">=</span> plt.subplot(<span class="dv">111</span>, projection<span class="op">=</span><span class="st">'3d'</span>)</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>x_coords, y_coords, z_coords <span class="op">=</span> <span class="bu">zip</span>(a,b)</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>subplot3d.scatter(x_coords, y_coords, z_coords)</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>subplot3d.set_zlim3d([<span class="dv">0</span>, <span class="dv">9</span>])</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="math_linear_algebra_files/figure-html/cell-12-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>It is a bit hard to visualize exactly where in space these two points are, so let’s add vertical lines. We’ll create a small convenience function to plot a list of 3d vectors with vertical lines attached:</p>
<div class="cell" data-execution_count="13">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> plot_vectors3d(ax, vectors3d, z0, <span class="op">**</span>options):</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> v <span class="kw">in</span> vectors3d:</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>        x, y, z <span class="op">=</span> v</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>        ax.plot([x,x], [y,y], [z0, z], color<span class="op">=</span><span class="st">"gray"</span>, linestyle<span class="op">=</span><span class="st">'dotted'</span>, marker<span class="op">=</span><span class="st">"."</span>)</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    x_coords, y_coords, z_coords <span class="op">=</span> <span class="bu">zip</span>(<span class="op">*</span>vectors3d)</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>    ax.scatter(x_coords, y_coords, z_coords, <span class="op">**</span>options)</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>subplot3d <span class="op">=</span> plt.subplot(<span class="dv">111</span>, projection<span class="op">=</span><span class="st">'3d'</span>)</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>subplot3d.set_zlim([<span class="dv">0</span>, <span class="dv">9</span>])</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>plot_vectors3d(subplot3d, [a,b], <span class="dv">0</span>, color<span class="op">=</span>(<span class="st">"r"</span>,<span class="st">"b"</span>))</span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="math_linear_algebra_files/figure-html/cell-13-output-1.png" class="img-fluid"></p>
</div>
</div>
</section>
</section>
<section id="norm" class="level2">
<h2 class="anchored" data-anchor-id="norm">Norm</h2>
<p>The norm of a vector <span class="math inline">\(\textbf{u}\)</span>, noted <span class="math inline">\(\left \Vert \textbf{u} \right \|\)</span>, is a measure of the length (a.k.a. the magnitude) of <span class="math inline">\(\textbf{u}\)</span>. There are multiple possible norms, but the most common one (and the only one we will discuss here) is the Euclidian norm, which is defined as:</p>
<p><span class="math inline">\(\left \Vert \textbf{u} \right \| = \sqrt{\sum_{i}{\textbf{u}_i}^2}\)</span></p>
<p>We could implement this easily in pure python, recalling that <span class="math inline">\(\sqrt x = x^{\frac{1}{2}}\)</span></p>
<div class="cell" data-execution_count="14">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> vector_norm(vector):</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>    squares <span class="op">=</span> [element<span class="op">**</span><span class="dv">2</span> <span class="cf">for</span> element <span class="kw">in</span> vector]</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">sum</span>(squares)<span class="op">**</span><span class="fl">0.5</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"||"</span>, u, <span class="st">"|| ="</span>)</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>vector_norm(u)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>|| [2 5] || =</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="14">
<pre><code>5.3851648071345037</code></pre>
</div>
</div>
<p>However, it is much more efficient to use NumPy’s <code>norm</code> function, available in the <code>linalg</code> (<strong>Lin</strong>ear <strong>Alg</strong>ebra) module:</p>
<div class="cell" data-execution_count="15">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy.linalg <span class="im">as</span> LA</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>LA.norm(u)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="15">
<pre><code>5.3851648071345037</code></pre>
</div>
</div>
<p>Let’s plot a little diagram to confirm that the length of vector <span class="math inline">\(\textbf{v}\)</span> is indeed <span class="math inline">\(\approx5.4\)</span>:</p>
<div class="cell" data-execution_count="16">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>radius <span class="op">=</span> LA.norm(u)</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>plt.gca().add_artist(plt.Circle((<span class="dv">0</span>,<span class="dv">0</span>), radius, color<span class="op">=</span><span class="st">"#DDDDDD"</span>))</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>plot_vector2d(u, color<span class="op">=</span><span class="st">"red"</span>)</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>plt.axis([<span class="dv">0</span>, <span class="fl">8.7</span>, <span class="dv">0</span>, <span class="dv">6</span>])</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>plt.grid()</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="math_linear_algebra_files/figure-html/cell-16-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>Looks about right!</p>
</section>
<section id="addition" class="level2">
<h2 class="anchored" data-anchor-id="addition">Addition</h2>
<p>Vectors of same size can be added together. Addition is performed <em>elementwise</em>:</p>
<div class="cell" data-execution_count="17">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">" "</span>, u)</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"+"</span>, v)</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"-"</span><span class="op">*</span><span class="dv">10</span>)</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>u <span class="op">+</span> v</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>  [2 5]
+ [3 1]
----------</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="17">
<pre><code>array([5, 6])</code></pre>
</div>
</div>
<p>Let’s look at what vector addition looks like graphically:</p>
<div class="cell" data-scrolled="true" data-execution_count="18">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>plot_vector2d(u, color<span class="op">=</span><span class="st">"r"</span>)</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>plot_vector2d(v, color<span class="op">=</span><span class="st">"b"</span>)</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>plot_vector2d(v, origin<span class="op">=</span>u, color<span class="op">=</span><span class="st">"b"</span>, linestyle<span class="op">=</span><span class="st">"dotted"</span>)</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>plot_vector2d(u, origin<span class="op">=</span>v, color<span class="op">=</span><span class="st">"r"</span>, linestyle<span class="op">=</span><span class="st">"dotted"</span>)</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>plot_vector2d(u<span class="op">+</span>v, color<span class="op">=</span><span class="st">"g"</span>)</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>plt.axis([<span class="dv">0</span>, <span class="dv">9</span>, <span class="dv">0</span>, <span class="dv">7</span>])</span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>plt.text(<span class="fl">0.7</span>, <span class="dv">3</span>, <span class="st">"u"</span>, color<span class="op">=</span><span class="st">"r"</span>, fontsize<span class="op">=</span><span class="dv">18</span>)</span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>plt.text(<span class="dv">4</span>, <span class="dv">3</span>, <span class="st">"u"</span>, color<span class="op">=</span><span class="st">"r"</span>, fontsize<span class="op">=</span><span class="dv">18</span>)</span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>plt.text(<span class="fl">1.8</span>, <span class="fl">0.2</span>, <span class="st">"v"</span>, color<span class="op">=</span><span class="st">"b"</span>, fontsize<span class="op">=</span><span class="dv">18</span>)</span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a>plt.text(<span class="fl">3.1</span>, <span class="fl">5.6</span>, <span class="st">"v"</span>, color<span class="op">=</span><span class="st">"b"</span>, fontsize<span class="op">=</span><span class="dv">18</span>)</span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a>plt.text(<span class="fl">2.4</span>, <span class="fl">2.5</span>, <span class="st">"u+v"</span>, color<span class="op">=</span><span class="st">"g"</span>, fontsize<span class="op">=</span><span class="dv">18</span>)</span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a>plt.grid()</span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="math_linear_algebra_files/figure-html/cell-18-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>Vector addition is <strong>commutative</strong>, meaning that <span class="math inline">\(\textbf{u} + \textbf{v} = \textbf{v} + \textbf{u}\)</span>. You can see it on the previous image: following <span class="math inline">\(\textbf{u}\)</span> <em>then</em> <span class="math inline">\(\textbf{v}\)</span> leads to the same point as following <span class="math inline">\(\textbf{v}\)</span> <em>then</em> <span class="math inline">\(\textbf{u}\)</span>.</p>
<p>Vector addition is also <strong>associative</strong>, meaning that <span class="math inline">\(\textbf{u} + (\textbf{v} + \textbf{w}) = (\textbf{u} + \textbf{v}) + \textbf{w}\)</span>.</p>
<p>If you have a shape defined by a number of points (vectors), and you add a vector <span class="math inline">\(\textbf{v}\)</span> to all of these points, then the whole shape gets shifted by <span class="math inline">\(\textbf{v}\)</span>. This is called a <a href="https://en.wikipedia.org/wiki/Translation_%28geometry%29">geometric translation</a>:</p>
<div class="cell" data-execution_count="19">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>t1 <span class="op">=</span> np.array([<span class="dv">2</span>, <span class="fl">0.25</span>])</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>t2 <span class="op">=</span> np.array([<span class="fl">2.5</span>, <span class="fl">3.5</span>])</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>t3 <span class="op">=</span> np.array([<span class="dv">1</span>, <span class="dv">2</span>])</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>x_coords, y_coords <span class="op">=</span> <span class="bu">zip</span>(t1, t2, t3, t1)</span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>plt.plot(x_coords, y_coords, <span class="st">"c--"</span>, x_coords, y_coords, <span class="st">"co"</span>)</span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>plot_vector2d(v, t1, color<span class="op">=</span><span class="st">"r"</span>, linestyle<span class="op">=</span><span class="st">":"</span>)</span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a>plot_vector2d(v, t2, color<span class="op">=</span><span class="st">"r"</span>, linestyle<span class="op">=</span><span class="st">":"</span>)</span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a>plot_vector2d(v, t3, color<span class="op">=</span><span class="st">"r"</span>, linestyle<span class="op">=</span><span class="st">":"</span>)</span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true" tabindex="-1"></a>t1b <span class="op">=</span> t1 <span class="op">+</span> v</span>
<span id="cb27-13"><a href="#cb27-13" aria-hidden="true" tabindex="-1"></a>t2b <span class="op">=</span> t2 <span class="op">+</span> v</span>
<span id="cb27-14"><a href="#cb27-14" aria-hidden="true" tabindex="-1"></a>t3b <span class="op">=</span> t3 <span class="op">+</span> v</span>
<span id="cb27-15"><a href="#cb27-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-16"><a href="#cb27-16" aria-hidden="true" tabindex="-1"></a>x_coords_b, y_coords_b <span class="op">=</span> <span class="bu">zip</span>(t1b, t2b, t3b, t1b)</span>
<span id="cb27-17"><a href="#cb27-17" aria-hidden="true" tabindex="-1"></a>plt.plot(x_coords_b, y_coords_b, <span class="st">"b-"</span>, x_coords_b, y_coords_b, <span class="st">"bo"</span>)</span>
<span id="cb27-18"><a href="#cb27-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-19"><a href="#cb27-19" aria-hidden="true" tabindex="-1"></a>plt.text(<span class="dv">4</span>, <span class="fl">4.2</span>, <span class="st">"v"</span>, color<span class="op">=</span><span class="st">"r"</span>, fontsize<span class="op">=</span><span class="dv">18</span>)</span>
<span id="cb27-20"><a href="#cb27-20" aria-hidden="true" tabindex="-1"></a>plt.text(<span class="dv">3</span>, <span class="fl">2.3</span>, <span class="st">"v"</span>, color<span class="op">=</span><span class="st">"r"</span>, fontsize<span class="op">=</span><span class="dv">18</span>)</span>
<span id="cb27-21"><a href="#cb27-21" aria-hidden="true" tabindex="-1"></a>plt.text(<span class="fl">3.5</span>, <span class="fl">0.4</span>, <span class="st">"v"</span>, color<span class="op">=</span><span class="st">"r"</span>, fontsize<span class="op">=</span><span class="dv">18</span>)</span>
<span id="cb27-22"><a href="#cb27-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-23"><a href="#cb27-23" aria-hidden="true" tabindex="-1"></a>plt.axis([<span class="dv">0</span>, <span class="dv">6</span>, <span class="dv">0</span>, <span class="dv">5</span>])</span>
<span id="cb27-24"><a href="#cb27-24" aria-hidden="true" tabindex="-1"></a>plt.grid()</span>
<span id="cb27-25"><a href="#cb27-25" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="math_linear_algebra_files/figure-html/cell-19-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>Finally, subtracting a vector is like adding the opposite vector.</p>
</section>
<section id="multiplication-by-a-scalar" class="level2">
<h2 class="anchored" data-anchor-id="multiplication-by-a-scalar">Multiplication by a scalar</h2>
<p>Vectors can be multiplied by scalars. All elements in the vector are multiplied by that number, for example:</p>
<div class="cell" data-execution_count="20">
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"1.5 *"</span>, u, <span class="st">"="</span>)</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a><span class="fl">1.5</span> <span class="op">*</span> u</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>1.5 * [2 5] =</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="20">
<pre><code>array([ 3. ,  7.5])</code></pre>
</div>
</div>
<p>Graphically, scalar multiplication results in changing the scale of a figure, hence the name <em>scalar</em>. The distance from the origin (the point at coordinates equal to zero) is also multiplied by the scalar. For example, let’s scale up by a factor of <code>k = 2.5</code>:</p>
<div class="cell" data-execution_count="21">
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>k <span class="op">=</span> <span class="fl">2.5</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>t1c <span class="op">=</span> k <span class="op">*</span> t1</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>t2c <span class="op">=</span> k <span class="op">*</span> t2</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>t3c <span class="op">=</span> k <span class="op">*</span> t3</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>plt.plot(x_coords, y_coords, <span class="st">"c--"</span>, x_coords, y_coords, <span class="st">"co"</span>)</span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a>plot_vector2d(t1, color<span class="op">=</span><span class="st">"r"</span>)</span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a>plot_vector2d(t2, color<span class="op">=</span><span class="st">"r"</span>)</span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a>plot_vector2d(t3, color<span class="op">=</span><span class="st">"r"</span>)</span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a>x_coords_c, y_coords_c <span class="op">=</span> <span class="bu">zip</span>(t1c, t2c, t3c, t1c)</span>
<span id="cb31-13"><a href="#cb31-13" aria-hidden="true" tabindex="-1"></a>plt.plot(x_coords_c, y_coords_c, <span class="st">"b-"</span>, x_coords_c, y_coords_c, <span class="st">"bo"</span>)</span>
<span id="cb31-14"><a href="#cb31-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-15"><a href="#cb31-15" aria-hidden="true" tabindex="-1"></a>plot_vector2d(k <span class="op">*</span> t1, color<span class="op">=</span><span class="st">"b"</span>, linestyle<span class="op">=</span><span class="st">":"</span>)</span>
<span id="cb31-16"><a href="#cb31-16" aria-hidden="true" tabindex="-1"></a>plot_vector2d(k <span class="op">*</span> t2, color<span class="op">=</span><span class="st">"b"</span>, linestyle<span class="op">=</span><span class="st">":"</span>)</span>
<span id="cb31-17"><a href="#cb31-17" aria-hidden="true" tabindex="-1"></a>plot_vector2d(k <span class="op">*</span> t3, color<span class="op">=</span><span class="st">"b"</span>, linestyle<span class="op">=</span><span class="st">":"</span>)</span>
<span id="cb31-18"><a href="#cb31-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-19"><a href="#cb31-19" aria-hidden="true" tabindex="-1"></a>plt.axis([<span class="dv">0</span>, <span class="dv">9</span>, <span class="dv">0</span>, <span class="dv">9</span>])</span>
<span id="cb31-20"><a href="#cb31-20" aria-hidden="true" tabindex="-1"></a>plt.grid()</span>
<span id="cb31-21"><a href="#cb31-21" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="math_linear_algebra_files/figure-html/cell-21-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>As you might guess, dividing a vector by a scalar is equivalent to multiplying by its multiplicative inverse (reciprocal):</p>
<p><span class="math inline">\(\dfrac{\textbf{u}}{\lambda} = \dfrac{1}{\lambda} \times \textbf{u}\)</span></p>
<p>Scalar multiplication is <strong>commutative</strong>: <span class="math inline">\(\lambda \times \textbf{u} = \textbf{u} \times \lambda\)</span>.</p>
<p>It is also <strong>associative</strong>: <span class="math inline">\(\lambda_1 \times (\lambda_2 \times \textbf{u}) = (\lambda_1 \times \lambda_2) \times \textbf{u}\)</span>.</p>
<p>Finally, it is <strong>distributive</strong> over addition of vectors: <span class="math inline">\(\lambda \times (\textbf{u} + \textbf{v}) = \lambda \times \textbf{u} + \lambda \times \textbf{v}\)</span>.</p>
</section>
<section id="zero-unit-and-normalized-vectors" class="level2">
<h2 class="anchored" data-anchor-id="zero-unit-and-normalized-vectors">Zero, unit and normalized vectors</h2>
<ul>
<li>A <strong>zero-vector </strong> is a vector full of 0s.</li>
<li>A <strong>unit vector</strong> is a vector with a norm equal to 1.</li>
<li>The <strong>normalized vector</strong> of a non-null vector <span class="math inline">\(\textbf{u}\)</span>, noted <span class="math inline">\(\hat{\textbf{u}}\)</span>, is the unit vector that points in the same direction as <span class="math inline">\(\textbf{u}\)</span>. It is equal to: <span class="math inline">\(\hat{\textbf{u}} = \dfrac{\textbf{u}}{\left \Vert \textbf{u} \right \|}\)</span></li>
</ul>
<div class="cell" data-execution_count="22">
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>plt.gca().add_artist(plt.Circle((<span class="dv">0</span>,<span class="dv">0</span>),<span class="dv">1</span>,color<span class="op">=</span><span class="st">'c'</span>))</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>plt.plot(<span class="dv">0</span>, <span class="dv">0</span>, <span class="st">"ko"</span>)</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>plot_vector2d(v <span class="op">/</span> LA.norm(v), color<span class="op">=</span><span class="st">"k"</span>)</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>plot_vector2d(v, color<span class="op">=</span><span class="st">"b"</span>, linestyle<span class="op">=</span><span class="st">":"</span>)</span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>plt.text(<span class="fl">0.3</span>, <span class="fl">0.3</span>, <span class="st">"$\hat</span><span class="sc">{u}</span><span class="st">$"</span>, color<span class="op">=</span><span class="st">"k"</span>, fontsize<span class="op">=</span><span class="dv">18</span>)</span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>plt.text(<span class="fl">1.5</span>, <span class="fl">0.7</span>, <span class="st">"$u$"</span>, color<span class="op">=</span><span class="st">"b"</span>, fontsize<span class="op">=</span><span class="dv">18</span>)</span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a>plt.axis([<span class="op">-</span><span class="fl">1.5</span>, <span class="fl">5.5</span>, <span class="op">-</span><span class="fl">1.5</span>, <span class="fl">3.5</span>])</span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a>plt.grid()</span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="math_linear_algebra_files/figure-html/cell-22-output-1.png" class="img-fluid"></p>
</div>
</div>
</section>
<section id="dot-product" class="level2">
<h2 class="anchored" data-anchor-id="dot-product">Dot product</h2>
<section id="definition-1" class="level3">
<h3 class="anchored" data-anchor-id="definition-1">Definition</h3>
<p>The dot product (also called <em>scalar product</em> or <em>inner product</em> in the context of the Euclidian space) of two vectors <span class="math inline">\(\textbf{u}\)</span> and <span class="math inline">\(\textbf{v}\)</span> is a useful operation that comes up fairly often in linear algebra. It is noted <span class="math inline">\(\textbf{u} \cdot \textbf{v}\)</span>, or sometimes <span class="math inline">\(⟨\textbf{u}|\textbf{v}⟩\)</span> or <span class="math inline">\((\textbf{u}|\textbf{v})\)</span>, and it is defined as:</p>
<p><span class="math inline">\(\textbf{u} \cdot \textbf{v} = \left \Vert \textbf{u} \right \| \times \left \Vert \textbf{v} \right \| \times cos(\theta)\)</span></p>
<p>where <span class="math inline">\(\theta\)</span> is the angle between <span class="math inline">\(\textbf{u}\)</span> and <span class="math inline">\(\textbf{v}\)</span>.</p>
<p>Another way to calculate the dot product is:</p>
<p><span class="math inline">\(\textbf{u} \cdot \textbf{v} = \sum_i{\textbf{u}_i \times \textbf{v}_i}\)</span></p>
</section>
<section id="in-python" class="level3">
<h3 class="anchored" data-anchor-id="in-python">In python</h3>
<p>The dot product is pretty simple to implement:</p>
<div class="cell" data-execution_count="23">
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dot_product(v1, v2):</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">sum</span>(v1i <span class="op">*</span> v2i <span class="cf">for</span> v1i, v2i <span class="kw">in</span> <span class="bu">zip</span>(v1, v2))</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>dot_product(u, v)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="23">
<pre><code>11</code></pre>
</div>
</div>
<p>But a <em>much</em> more efficient implementation is provided by NumPy with the <code>dot</code> function:</p>
<div class="cell" data-execution_count="24">
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>np.dot(u,v)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="24">
<pre><code>11</code></pre>
</div>
</div>
<p>Equivalently, you can use the <code>dot</code> method of <code>ndarray</code>s:</p>
<div class="cell" data-execution_count="25">
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>u.dot(v)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="25">
<pre><code>11</code></pre>
</div>
</div>
<p><strong>Caution</strong>: the <code>*</code> operator will perform an <em>elementwise</em> multiplication, <em>NOT</em> a dot product:</p>
<div class="cell" data-execution_count="26">
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"  "</span>,u)</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"* "</span>,v, <span class="st">"(NOT a dot product)"</span>)</span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"-"</span><span class="op">*</span><span class="dv">10</span>)</span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>u <span class="op">*</span> v</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>   [2 5]
*  [3 1] (NOT a dot product)
----------</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="26">
<pre><code>array([6, 5])</code></pre>
</div>
</div>
</section>
<section id="main-properties" class="level3">
<h3 class="anchored" data-anchor-id="main-properties">Main properties</h3>
<ul>
<li>The dot product is <strong>commutative</strong>: <span class="math inline">\(\textbf{u} \cdot \textbf{v} = \textbf{v} \cdot \textbf{u}\)</span>.</li>
<li>The dot product is only defined between two vectors, not between a scalar and a vector. This means that we cannot chain dot products: for example, the expression <span class="math inline">\(\textbf{u} \cdot \textbf{v} \cdot \textbf{w}\)</span> is not defined since <span class="math inline">\(\textbf{u} \cdot \textbf{v}\)</span> is a scalar and <span class="math inline">\(\textbf{w}\)</span> is a vector.</li>
<li>This also means that the dot product is <strong>NOT associative</strong>: <span class="math inline">\((\textbf{u} \cdot \textbf{v}) \cdot \textbf{w} ≠ \textbf{u} \cdot (\textbf{v} \cdot \textbf{w})\)</span> since neither are defined.</li>
<li>However, the dot product is <strong>associative with regards to scalar multiplication</strong>: <span class="math inline">\(\lambda \times (\textbf{u} \cdot \textbf{v}) = (\lambda \times \textbf{u}) \cdot \textbf{v} = \textbf{u} \cdot (\lambda \times \textbf{v})\)</span></li>
<li>Finally, the dot product is <strong>distributive</strong> over addition of vectors: <span class="math inline">\(\textbf{u} \cdot (\textbf{v} + \textbf{w}) = \textbf{u} \cdot \textbf{v} + \textbf{u} \cdot \textbf{w}\)</span>.</li>
</ul>
</section>
<section id="calculating-the-angle-between-vectors" class="level3">
<h3 class="anchored" data-anchor-id="calculating-the-angle-between-vectors">Calculating the angle between vectors</h3>
<p>One of the many uses of the dot product is to calculate the angle between two non-zero vectors. Looking at the dot product definition, we can deduce the following formula:</p>
<p><span class="math inline">\(\theta = \arccos{\left ( \dfrac{\textbf{u} \cdot \textbf{v}}{\left \Vert \textbf{u} \right \| \times \left \Vert \textbf{v} \right \|} \right ) }\)</span></p>
<p>Note that if <span class="math inline">\(\textbf{u} \cdot \textbf{v} = 0\)</span>, it follows that <span class="math inline">\(\theta = \dfrac{π}{2}\)</span>. In other words, if the dot product of two non-null vectors is zero, it means that they are orthogonal.</p>
<p>Let’s use this formula to calculate the angle between <span class="math inline">\(\textbf{u}\)</span> and <span class="math inline">\(\textbf{v}\)</span> (in radians):</p>
<div class="cell" data-execution_count="27">
<div class="sourceCode cell-code" id="cb42"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> vector_angle(u, v):</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>    cos_theta <span class="op">=</span> u.dot(v) <span class="op">/</span> LA.norm(u) <span class="op">/</span> LA.norm(v)</span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.arccos(np.clip(cos_theta, <span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>))</span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a>theta <span class="op">=</span> vector_angle(u, v)</span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Angle ="</span>, theta, <span class="st">"radians"</span>)</span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"      ="</span>, theta <span class="op">*</span> <span class="dv">180</span> <span class="op">/</span> np.pi, <span class="st">"degrees"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Angle = 0.868539395286 radians
      = 49.7636416907 degrees</code></pre>
</div>
</div>
<p>Note: due to small floating point errors, <code>cos_theta</code> may be very slightly outside of the <span class="math inline">\([-1, 1]\)</span> interval, which would make <code>arccos</code> fail. This is why we clipped the value within the range, using NumPy’s <code>clip</code> function.</p>
</section>
<section id="projecting-a-point-onto-an-axis" class="level3">
<h3 class="anchored" data-anchor-id="projecting-a-point-onto-an-axis">Projecting a point onto an axis</h3>
<p>The dot product is also very useful to project points onto an axis. The projection of vector <span class="math inline">\(\textbf{v}\)</span> onto <span class="math inline">\(\textbf{u}\)</span>’s axis is given by this formula:</p>
<p><span class="math inline">\(\textbf{proj}_{\textbf{u}}{\textbf{v}} = \dfrac{\textbf{u} \cdot \textbf{v}}{\left \Vert \textbf{u} \right \| ^2} \times \textbf{u}\)</span></p>
<p>Which is equivalent to:</p>
<p><span class="math inline">\(\textbf{proj}_{\textbf{u}}{\textbf{v}} = (\textbf{v} \cdot \hat{\textbf{u}}) \times \hat{\textbf{u}}\)</span></p>
<div class="cell" data-execution_count="28">
<div class="sourceCode cell-code" id="cb44"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>u_normalized <span class="op">=</span> u <span class="op">/</span> LA.norm(u)</span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>proj <span class="op">=</span> v.dot(u_normalized) <span class="op">*</span> u_normalized</span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a>plot_vector2d(u, color<span class="op">=</span><span class="st">"r"</span>)</span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a>plot_vector2d(v, color<span class="op">=</span><span class="st">"b"</span>)</span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true" tabindex="-1"></a>plot_vector2d(proj, color<span class="op">=</span><span class="st">"k"</span>, linestyle<span class="op">=</span><span class="st">":"</span>)</span>
<span id="cb44-8"><a href="#cb44-8" aria-hidden="true" tabindex="-1"></a>plt.plot(proj[<span class="dv">0</span>], proj[<span class="dv">1</span>], <span class="st">"ko"</span>)</span>
<span id="cb44-9"><a href="#cb44-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-10"><a href="#cb44-10" aria-hidden="true" tabindex="-1"></a>plt.plot([proj[<span class="dv">0</span>], v[<span class="dv">0</span>]], [proj[<span class="dv">1</span>], v[<span class="dv">1</span>]], <span class="st">"b:"</span>)</span>
<span id="cb44-11"><a href="#cb44-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-12"><a href="#cb44-12" aria-hidden="true" tabindex="-1"></a>plt.text(<span class="dv">1</span>, <span class="dv">2</span>, <span class="st">"$proj_u v$"</span>, color<span class="op">=</span><span class="st">"k"</span>, fontsize<span class="op">=</span><span class="dv">18</span>)</span>
<span id="cb44-13"><a href="#cb44-13" aria-hidden="true" tabindex="-1"></a>plt.text(<span class="fl">1.8</span>, <span class="fl">0.2</span>, <span class="st">"$v$"</span>, color<span class="op">=</span><span class="st">"b"</span>, fontsize<span class="op">=</span><span class="dv">18</span>)</span>
<span id="cb44-14"><a href="#cb44-14" aria-hidden="true" tabindex="-1"></a>plt.text(<span class="fl">0.8</span>, <span class="dv">3</span>, <span class="st">"$u$"</span>, color<span class="op">=</span><span class="st">"r"</span>, fontsize<span class="op">=</span><span class="dv">18</span>)</span>
<span id="cb44-15"><a href="#cb44-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-16"><a href="#cb44-16" aria-hidden="true" tabindex="-1"></a>plt.axis([<span class="dv">0</span>, <span class="dv">8</span>, <span class="dv">0</span>, <span class="fl">5.5</span>])</span>
<span id="cb44-17"><a href="#cb44-17" aria-hidden="true" tabindex="-1"></a>plt.grid()</span>
<span id="cb44-18"><a href="#cb44-18" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="math_linear_algebra_files/figure-html/cell-28-output-1.png" class="img-fluid"></p>
</div>
</div>
</section>
</section>
</section>
<section id="matrices" class="level1">
<h1>Matrices</h1>
<p>A matrix is a rectangular array of scalars (ie. any number: integer, real or complex) arranged in rows and columns, for example:</p>
<span class="math display">\[\begin{bmatrix} 10 &amp; 20 &amp; 30 \\ 40 &amp; 50 &amp; 60 \end{bmatrix}\]</span>
<p>You can also think of a matrix as a list of vectors: the previous matrix contains either 2 horizontal 3D vectors or 3 vertical 2D vectors.</p>
<p>Matrices are convenient and very efficient to run operations on many vectors at a time. We will also see that they are great at representing and performing linear transformations such rotations, translations and scaling.</p>
<section id="matrices-in-python" class="level2">
<h2 class="anchored" data-anchor-id="matrices-in-python">Matrices in python</h2>
<p>In python, a matrix can be represented in various ways. The simplest is just a list of python lists:</p>
<div class="cell" data-execution_count="29">
<div class="sourceCode cell-code" id="cb45"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>[</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">10</span>, <span class="dv">20</span>, <span class="dv">30</span>],</span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">40</span>, <span class="dv">50</span>, <span class="dv">60</span>]</span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="29">
<pre><code>[[10, 20, 30], [40, 50, 60]]</code></pre>
</div>
</div>
<p>A much more efficient way is to use the NumPy library which provides optimized implementations of many matrix operations:</p>
<div class="cell" data-execution_count="30">
<div class="sourceCode cell-code" id="cb47"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> np.array([</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">10</span>,<span class="dv">20</span>,<span class="dv">30</span>],</span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">40</span>,<span class="dv">50</span>,<span class="dv">60</span>]</span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a>])</span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a>A</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="30">
<pre><code>array([[10, 20, 30],
       [40, 50, 60]])</code></pre>
</div>
</div>
<p>By convention matrices generally have uppercase names, such as <span class="math inline">\(A\)</span>.</p>
<p>In the rest of this tutorial, we will assume that we are using NumPy arrays (type <code>ndarray</code>) to represent matrices.</p>
</section>
<section id="size" class="level2">
<h2 class="anchored" data-anchor-id="size">Size</h2>
<p>The size of a matrix is defined by its number of rows and number of columns. It is noted <span class="math inline">\(rows \times columns\)</span>. For example, the matrix <span class="math inline">\(A\)</span> above is an example of a <span class="math inline">\(2 \times 3\)</span> matrix: 2 rows, 3 columns. Caution: a <span class="math inline">\(3 \times 2\)</span> matrix would have 3 rows and 2 columns.</p>
<p>To get a matrix’s size in NumPy:</p>
<div class="cell" data-execution_count="31">
<div class="sourceCode cell-code" id="cb49"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a>A.shape</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="31">
<pre><code>(2, 3)</code></pre>
</div>
</div>
<p><strong>Caution</strong>: the <code>size</code> attribute represents the number of elements in the <code>ndarray</code>, not the matrix’s size:</p>
<div class="cell" data-execution_count="32">
<div class="sourceCode cell-code" id="cb51"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a>A.size</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="32">
<pre><code>6</code></pre>
</div>
</div>
</section>
<section id="element-indexing" class="level2">
<h2 class="anchored" data-anchor-id="element-indexing">Element indexing</h2>
<p>The number located in the <span class="math inline">\(i^{th}\)</span> row, and <span class="math inline">\(j^{th}\)</span> column of a matrix <span class="math inline">\(X\)</span> is sometimes noted <span class="math inline">\(X_{i,j}\)</span> or <span class="math inline">\(X_{ij}\)</span>, but there is no standard notation, so people often prefer to explicitely name the elements, like this: “<em>let <span class="math inline">\(X = (x_{i,j})_{1 ≤ i ≤ m, 1 ≤ j ≤ n}\)</span></em>”. This means that <span class="math inline">\(X\)</span> is equal to:</p>
<p><span class="math inline">\(X = \begin{bmatrix}  x_{1,1} &amp; x_{1,2} &amp; x_{1,3} &amp; \cdots &amp; x_{1,n}\\  x_{2,1} &amp; x_{2,2} &amp; x_{2,3} &amp; \cdots &amp; x_{2,n}\\  x_{3,1} &amp; x_{3,2} &amp; x_{3,3} &amp; \cdots &amp; x_{3,n}\\  \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\  x_{m,1} &amp; x_{m,2} &amp; x_{m,3} &amp; \cdots &amp; x_{m,n}\\ \end{bmatrix}\)</span></p>
<p>However in this notebook we will use the <span class="math inline">\(X_{i,j}\)</span> notation, as it matches fairly well NumPy’s notation. Note that in math indices generally start at 1, but in programming they usually start at 0. So to access <span class="math inline">\(A_{2,3}\)</span> programmatically, we need to write this:</p>
<div class="cell" data-execution_count="33">
<div class="sourceCode cell-code" id="cb53"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a>A[<span class="dv">1</span>,<span class="dv">2</span>]  <span class="co"># 2nd row, 3rd column</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="33">
<pre><code>60</code></pre>
</div>
</div>
<p>The <span class="math inline">\(i^{th}\)</span> row vector is sometimes noted <span class="math inline">\(M_i\)</span> or <span class="math inline">\(M_{i,*}\)</span>, but again there is no standard notation so people often prefer to explicitely define their own names, for example: “<em>let <strong>x</strong><span class="math inline">\(_{i}\)</span> be the <span class="math inline">\(i^{th}\)</span> row vector of matrix <span class="math inline">\(X\)</span></em>”. We will use the <span class="math inline">\(M_{i,*}\)</span>, for the same reason as above. For example, to access <span class="math inline">\(A_{2,*}\)</span> (ie. <span class="math inline">\(A\)</span>’s 2nd row vector):</p>
<div class="cell" data-execution_count="34">
<div class="sourceCode cell-code" id="cb55"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a>A[<span class="dv">1</span>, :]  <span class="co"># 2nd row vector (as a 1D array)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="34">
<pre><code>array([40, 50, 60])</code></pre>
</div>
</div>
<p>Similarly, the <span class="math inline">\(j^{th}\)</span> column vector is sometimes noted <span class="math inline">\(M^j\)</span> or <span class="math inline">\(M_{*,j}\)</span>, but there is no standard notation. We will use <span class="math inline">\(M_{*,j}\)</span>. For example, to access <span class="math inline">\(A_{*,3}\)</span> (ie. <span class="math inline">\(A\)</span>’s 3rd column vector):</p>
<div class="cell" data-execution_count="35">
<div class="sourceCode cell-code" id="cb57"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a>A[:, <span class="dv">2</span>]  <span class="co"># 3rd column vector (as a 1D array)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="35">
<pre><code>array([30, 60])</code></pre>
</div>
</div>
<p>Note that the result is actually a one-dimensional NumPy array: there is no such thing as a <em>vertical</em> or <em>horizontal</em> one-dimensional array. If you need to actually represent a row vector as a one-row matrix (ie. a 2D NumPy array), or a column vector as a one-column matrix, then you need to use a slice instead of an integer when accessing the row or column, for example:</p>
<div class="cell" data-execution_count="36">
<div class="sourceCode cell-code" id="cb59"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a>A[<span class="dv">1</span>:<span class="dv">2</span>, :]  <span class="co"># rows 2 to 3 (excluded): this returns row 2 as a one-row matrix</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="36">
<pre><code>array([[40, 50, 60]])</code></pre>
</div>
</div>
<div class="cell" data-execution_count="37">
<div class="sourceCode cell-code" id="cb61"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a>A[:, <span class="dv">2</span>:<span class="dv">3</span>]  <span class="co"># columns 3 to 4 (excluded): this returns column 3 as a one-column matrix</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="37">
<pre><code>array([[30],
       [60]])</code></pre>
</div>
</div>
</section>
<section id="square-triangular-diagonal-and-identity-matrices" class="level2">
<h2 class="anchored" data-anchor-id="square-triangular-diagonal-and-identity-matrices">Square, triangular, diagonal and identity matrices</h2>
<p>A <strong>square matrix</strong> is a matrix that has the same number of rows and columns, for example a <span class="math inline">\(3 \times 3\)</span> matrix:</p>
<span class="math display">\[\begin{bmatrix}
  4 &amp; 9 &amp; 2 \\
  3 &amp; 5 &amp; 7 \\
  8 &amp; 1 &amp; 6
\end{bmatrix}\]</span>
<p>An <strong>upper triangular matrix</strong> is a special kind of square matrix where all the elements <em>below</em> the main diagonal (top-left to bottom-right) are zero, for example:</p>
<span class="math display">\[\begin{bmatrix}
  4 &amp; 9 &amp; 2 \\
  0 &amp; 5 &amp; 7 \\
  0 &amp; 0 &amp; 6
\end{bmatrix}\]</span>
<p>Similarly, a <strong>lower triangular matrix</strong> is a square matrix where all elements <em>above</em> the main diagonal are zero, for example:</p>
<span class="math display">\[\begin{bmatrix}
  4 &amp; 0 &amp; 0 \\
  3 &amp; 5 &amp; 0 \\
  8 &amp; 1 &amp; 6
\end{bmatrix}\]</span>
<p>A <strong>triangular matrix</strong> is one that is either lower triangular or upper triangular.</p>
<p>A matrix that is both upper and lower triangular is called a <strong>diagonal matrix</strong>, for example:</p>
<span class="math display">\[\begin{bmatrix}
  4 &amp; 0 &amp; 0 \\
  0 &amp; 5 &amp; 0 \\
  0 &amp; 0 &amp; 6
\end{bmatrix}\]</span>
<p>You can construct a diagonal matrix using NumPy’s <code>diag</code> function:</p>
<div class="cell" data-execution_count="38">
<div class="sourceCode cell-code" id="cb63"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a>np.diag([<span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="38">
<pre><code>array([[4, 0, 0],
       [0, 5, 0],
       [0, 0, 6]])</code></pre>
</div>
</div>
<p>If you pass a matrix to the <code>diag</code> function, it will happily extract the diagonal values:</p>
<div class="cell" data-execution_count="39">
<div class="sourceCode cell-code" id="cb65"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a>D <span class="op">=</span> np.array([</span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a>        [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>],</span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a>        [<span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>],</span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true" tabindex="-1"></a>        [<span class="dv">7</span>, <span class="dv">8</span>, <span class="dv">9</span>],</span>
<span id="cb65-5"><a href="#cb65-5" aria-hidden="true" tabindex="-1"></a>    ])</span>
<span id="cb65-6"><a href="#cb65-6" aria-hidden="true" tabindex="-1"></a>np.diag(D)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="39">
<pre><code>array([1, 5, 9])</code></pre>
</div>
</div>
<p>Finally, the <strong>identity matrix</strong> of size <span class="math inline">\(n\)</span>, noted <span class="math inline">\(I_n\)</span>, is a diagonal matrix of size <span class="math inline">\(n \times n\)</span> with <span class="math inline">\(1\)</span>’s in the main diagonal, for example <span class="math inline">\(I_3\)</span>:</p>
<span class="math display">\[\begin{bmatrix}
  1 &amp; 0 &amp; 0 \\
  0 &amp; 1 &amp; 0 \\
  0 &amp; 0 &amp; 1
\end{bmatrix}\]</span>
<p>Numpy’s <code>eye</code> function returns the identity matrix of the desired size:</p>
<div class="cell" data-execution_count="40">
<div class="sourceCode cell-code" id="cb67"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a>np.eye(<span class="dv">3</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="40">
<pre><code>array([[ 1.,  0.,  0.],
       [ 0.,  1.,  0.],
       [ 0.,  0.,  1.]])</code></pre>
</div>
</div>
<p>The identity matrix is often noted simply <span class="math inline">\(I\)</span> (instead of <span class="math inline">\(I_n\)</span>) when its size is clear given the context. It is called the <em>identity</em> matrix because multiplying a matrix with it leaves the matrix unchanged as we will see below.</p>
</section>
<section id="adding-matrices" class="level2">
<h2 class="anchored" data-anchor-id="adding-matrices">Adding matrices</h2>
<p>If two matrices <span class="math inline">\(Q\)</span> and <span class="math inline">\(R\)</span> have the same size <span class="math inline">\(m \times n\)</span>, they can be added together. Addition is performed <em>elementwise</em>: the result is also a <span class="math inline">\(m \times n\)</span> matrix <span class="math inline">\(S\)</span> where each element is the sum of the elements at the corresponding position: <span class="math inline">\(S_{i,j} = Q_{i,j} + R_{i,j}\)</span></p>
<p><span class="math inline">\(S = \begin{bmatrix}  Q_{11} + R_{11} &amp; Q_{12} + R_{12} &amp; Q_{13} + R_{13} &amp; \cdots &amp; Q_{1n} + R_{1n} \\  Q_{21} + R_{21} &amp; Q_{22} + R_{22} &amp; Q_{23} + R_{23} &amp; \cdots &amp; Q_{2n} + R_{2n} \\  Q_{31} + R_{31} &amp; Q_{32} + R_{32} &amp; Q_{33} + R_{33} &amp; \cdots &amp; Q_{3n} + R_{3n} \\  \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\  Q_{m1} + R_{m1} &amp; Q_{m2} + R_{m2} &amp; Q_{m3} + R_{m3} &amp; \cdots &amp; Q_{mn} + R_{mn} \\ \end{bmatrix}\)</span></p>
<p>For example, let’s create a <span class="math inline">\(2 \times 3\)</span> matrix <span class="math inline">\(B\)</span> and compute <span class="math inline">\(A + B\)</span>:</p>
<div class="cell" data-execution_count="41">
<div class="sourceCode cell-code" id="cb69"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a>B <span class="op">=</span> np.array([[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>], [<span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>]])</span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a>B</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="41">
<pre><code>array([[1, 2, 3],
       [4, 5, 6]])</code></pre>
</div>
</div>
<div class="cell" data-execution_count="42">
<div class="sourceCode cell-code" id="cb71"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a>A</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="42">
<pre><code>array([[10, 20, 30],
       [40, 50, 60]])</code></pre>
</div>
</div>
<div class="cell" data-execution_count="43">
<div class="sourceCode cell-code" id="cb73"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a>A <span class="op">+</span> B</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="43">
<pre><code>array([[11, 22, 33],
       [44, 55, 66]])</code></pre>
</div>
</div>
<p><strong>Addition is <em>commutative</em></strong>, meaning that <span class="math inline">\(A + B = B + A\)</span>:</p>
<div class="cell" data-execution_count="44">
<div class="sourceCode cell-code" id="cb75"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a>B <span class="op">+</span> A</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="44">
<pre><code>array([[11, 22, 33],
       [44, 55, 66]])</code></pre>
</div>
</div>
<p><strong>It is also <em>associative</em></strong>, meaning that <span class="math inline">\(A + (B + C) = (A + B) + C\)</span>:</p>
<div class="cell" data-execution_count="45">
<div class="sourceCode cell-code" id="cb77"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a>C <span class="op">=</span> np.array([[<span class="dv">100</span>,<span class="dv">200</span>,<span class="dv">300</span>], [<span class="dv">400</span>, <span class="dv">500</span>, <span class="dv">600</span>]])</span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-3"><a href="#cb77-3" aria-hidden="true" tabindex="-1"></a>A <span class="op">+</span> (B <span class="op">+</span> C)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="45">
<pre><code>array([[111, 222, 333],
       [444, 555, 666]])</code></pre>
</div>
</div>
<div class="cell" data-execution_count="46">
<div class="sourceCode cell-code" id="cb79"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a>(A <span class="op">+</span> B) <span class="op">+</span> C</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="46">
<pre><code>array([[111, 222, 333],
       [444, 555, 666]])</code></pre>
</div>
</div>
</section>
<section id="scalar-multiplication" class="level2">
<h2 class="anchored" data-anchor-id="scalar-multiplication">Scalar multiplication</h2>
<p>A matrix <span class="math inline">\(M\)</span> can be multiplied by a scalar <span class="math inline">\(\lambda\)</span>. The result is noted <span class="math inline">\(\lambda M\)</span>, and it is a matrix of the same size as <span class="math inline">\(M\)</span> with all elements multiplied by <span class="math inline">\(\lambda\)</span>:</p>
<p><span class="math inline">\(\lambda M = \begin{bmatrix}  \lambda \times M_{11} &amp; \lambda \times M_{12} &amp; \lambda \times M_{13} &amp; \cdots &amp; \lambda \times M_{1n} \\  \lambda \times M_{21} &amp; \lambda \times M_{22} &amp; \lambda \times M_{23} &amp; \cdots &amp; \lambda \times M_{2n} \\  \lambda \times M_{31} &amp; \lambda \times M_{32} &amp; \lambda \times M_{33} &amp; \cdots &amp; \lambda \times M_{3n} \\  \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\  \lambda \times M_{m1} &amp; \lambda \times M_{m2} &amp; \lambda \times M_{m3} &amp; \cdots &amp; \lambda \times M_{mn} \\ \end{bmatrix}\)</span></p>
<p>A more concise way of writing this is:</p>
<p><span class="math inline">\((\lambda M)_{i,j} = \lambda (M)_{i,j}\)</span></p>
<p>In NumPy, simply use the <code>*</code> operator to multiply a matrix by a scalar. For example:</p>
<div class="cell" data-execution_count="47">
<div class="sourceCode cell-code" id="cb81"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a><span class="dv">2</span> <span class="op">*</span> A</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="47">
<pre><code>array([[ 20,  40,  60],
       [ 80, 100, 120]])</code></pre>
</div>
</div>
<p>Scalar multiplication is also defined on the right hand side, and gives the same result: <span class="math inline">\(M \lambda = \lambda M\)</span>. For example:</p>
<div class="cell" data-execution_count="48">
<div class="sourceCode cell-code" id="cb83"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a>A <span class="op">*</span> <span class="dv">2</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="48">
<pre><code>array([[ 20,  40,  60],
       [ 80, 100, 120]])</code></pre>
</div>
</div>
<p>This makes scalar multiplication <strong>commutative</strong>.</p>
<p>It is also <strong>associative</strong>, meaning that <span class="math inline">\(\alpha (\beta M) = (\alpha \times \beta) M\)</span>, where <span class="math inline">\(\alpha\)</span> and <span class="math inline">\(\beta\)</span> are scalars. For example:</p>
<div class="cell" data-execution_count="49">
<div class="sourceCode cell-code" id="cb85"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a><span class="dv">2</span> <span class="op">*</span> (<span class="dv">3</span> <span class="op">*</span> A)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="49">
<pre><code>array([[ 60, 120, 180],
       [240, 300, 360]])</code></pre>
</div>
</div>
<div class="cell" data-execution_count="50">
<div class="sourceCode cell-code" id="cb87"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a>(<span class="dv">2</span> <span class="op">*</span> <span class="dv">3</span>) <span class="op">*</span> A</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="50">
<pre><code>array([[ 60, 120, 180],
       [240, 300, 360]])</code></pre>
</div>
</div>
<p>Finally, it is <strong>distributive over addition</strong> of matrices, meaning that <span class="math inline">\(\lambda (Q + R) = \lambda Q + \lambda R\)</span>:</p>
<div class="cell" data-execution_count="51">
<div class="sourceCode cell-code" id="cb89"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a><span class="dv">2</span> <span class="op">*</span> (A <span class="op">+</span> B)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="51">
<pre><code>array([[ 22,  44,  66],
       [ 88, 110, 132]])</code></pre>
</div>
</div>
<div class="cell" data-execution_count="52">
<div class="sourceCode cell-code" id="cb91"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a><span class="dv">2</span> <span class="op">*</span> A <span class="op">+</span> <span class="dv">2</span> <span class="op">*</span> B</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="52">
<pre><code>array([[ 22,  44,  66],
       [ 88, 110, 132]])</code></pre>
</div>
</div>
</section>
<section id="matrix-multiplication" class="level2">
<h2 class="anchored" data-anchor-id="matrix-multiplication">Matrix multiplication</h2>
<p>So far, matrix operations have been rather intuitive. But multiplying matrices is a bit more involved.</p>
<p>A matrix <span class="math inline">\(Q\)</span> of size <span class="math inline">\(m \times n\)</span> can be multiplied by a matrix <span class="math inline">\(R\)</span> of size <span class="math inline">\(n \times q\)</span>. It is noted simply <span class="math inline">\(QR\)</span> without multiplication sign or dot. The result <span class="math inline">\(P\)</span> is an <span class="math inline">\(m \times q\)</span> matrix where each element is computed as a sum of products:</p>
<p><span class="math inline">\(P_{i,j} = \sum_{k=1}^n{Q_{i,k} \times R_{k,j}}\)</span></p>
<p>The element at position <span class="math inline">\(i,j\)</span> in the resulting matrix is the sum of the products of elements in row <span class="math inline">\(i\)</span> of matrix <span class="math inline">\(Q\)</span> by the elements in column <span class="math inline">\(j\)</span> of matrix <span class="math inline">\(R\)</span>.</p>
<p><span class="math inline">\(P = \begin{bmatrix} Q_{11} R_{11} + Q_{12} R_{21} + \cdots + Q_{1n} R_{n1} &amp;  Q_{11} R_{12} + Q_{12} R_{22} + \cdots + Q_{1n} R_{n2} &amp;  \cdots &amp;  Q_{11} R_{1q} + Q_{12} R_{2q} + \cdots + Q_{1n} R_{nq} \\ Q_{21} R_{11} + Q_{22} R_{21} + \cdots + Q_{2n} R_{n1} &amp;  Q_{21} R_{12} + Q_{22} R_{22} + \cdots + Q_{2n} R_{n2} &amp;  \cdots &amp;  Q_{21} R_{1q} + Q_{22} R_{2q} + \cdots + Q_{2n} R_{nq} \\  \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ Q_{m1} R_{11} + Q_{m2} R_{21} + \cdots + Q_{mn} R_{n1} &amp;  Q_{m1} R_{12} + Q_{m2} R_{22} + \cdots + Q_{mn} R_{n2} &amp;  \cdots &amp;  Q_{m1} R_{1q} + Q_{m2} R_{2q} + \cdots + Q_{mn} R_{nq} \end{bmatrix}\)</span></p>
<p>You may notice that each element <span class="math inline">\(P_{i,j}\)</span> is the dot product of the row vector <span class="math inline">\(Q_{i,*}\)</span> and the column vector <span class="math inline">\(R_{*,j}\)</span>:</p>
<p><span class="math inline">\(P_{i,j} = Q_{i,*} \cdot R_{*,j}\)</span></p>
<p>So we can rewrite <span class="math inline">\(P\)</span> more concisely as:</p>
<p><span class="math inline">\(P = \begin{bmatrix} Q_{1,*} \cdot R_{*,1} &amp; Q_{1,*} \cdot R_{*,2} &amp; \cdots &amp; Q_{1,*} \cdot R_{*,q} \\ Q_{2,*} \cdot R_{*,1} &amp; Q_{2,*} \cdot R_{*,2} &amp; \cdots &amp; Q_{2,*} \cdot R_{*,q} \\ \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ Q_{m,*} \cdot R_{*,1} &amp; Q_{m,*} \cdot R_{*,2} &amp; \cdots &amp; Q_{m,*} \cdot R_{*,q} \end{bmatrix}\)</span></p>
<p>Let’s multiply two matrices in NumPy, using <code>ndarray</code>’s <code>dot</code> method:</p>
<p><span class="math inline">\(E = AD = \begin{bmatrix}  10 &amp; 20 &amp; 30 \\  40 &amp; 50 &amp; 60 \end{bmatrix} \begin{bmatrix}  2 &amp; 3 &amp; 5 &amp; 7 \\  11 &amp; 13 &amp; 17 &amp; 19 \\  23 &amp; 29 &amp; 31 &amp; 37 \end{bmatrix} = \begin{bmatrix}  930 &amp; 1160 &amp; 1320 &amp; 1560 \\  2010 &amp; 2510 &amp; 2910 &amp; 3450 \end{bmatrix}\)</span></p>
<div class="cell" data-execution_count="53">
<div class="sourceCode cell-code" id="cb93"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a>D <span class="op">=</span> np.array([</span>
<span id="cb93-2"><a href="#cb93-2" aria-hidden="true" tabindex="-1"></a>        [ <span class="dv">2</span>,  <span class="dv">3</span>,  <span class="dv">5</span>,  <span class="dv">7</span>],</span>
<span id="cb93-3"><a href="#cb93-3" aria-hidden="true" tabindex="-1"></a>        [<span class="dv">11</span>, <span class="dv">13</span>, <span class="dv">17</span>, <span class="dv">19</span>],</span>
<span id="cb93-4"><a href="#cb93-4" aria-hidden="true" tabindex="-1"></a>        [<span class="dv">23</span>, <span class="dv">29</span>, <span class="dv">31</span>, <span class="dv">37</span>]</span>
<span id="cb93-5"><a href="#cb93-5" aria-hidden="true" tabindex="-1"></a>    ])</span>
<span id="cb93-6"><a href="#cb93-6" aria-hidden="true" tabindex="-1"></a>E <span class="op">=</span> A.dot(D)</span>
<span id="cb93-7"><a href="#cb93-7" aria-hidden="true" tabindex="-1"></a>E</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="53">
<pre><code>array([[ 930, 1160, 1320, 1560],
       [2010, 2510, 2910, 3450]])</code></pre>
</div>
</div>
<p>Let’s check this result by looking at one element, just to be sure: looking at <span class="math inline">\(E_{2,3}\)</span> for example, we need to multiply elements in <span class="math inline">\(A\)</span>’s <span class="math inline">\(2^{nd}\)</span> row by elements in <span class="math inline">\(D\)</span>’s <span class="math inline">\(3^{rd}\)</span> column, and sum up these products:</p>
<div class="cell" data-execution_count="54">
<div class="sourceCode cell-code" id="cb95"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true" tabindex="-1"></a><span class="dv">40</span><span class="op">*</span><span class="dv">5</span> <span class="op">+</span> <span class="dv">50</span><span class="op">*</span><span class="dv">17</span> <span class="op">+</span> <span class="dv">60</span><span class="op">*</span><span class="dv">31</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="54">
<pre><code>2910</code></pre>
</div>
</div>
<div class="cell" data-execution_count="55">
<div class="sourceCode cell-code" id="cb97"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true" tabindex="-1"></a>E[<span class="dv">1</span>,<span class="dv">2</span>]  <span class="co"># row 2, column 3</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="55">
<pre><code>2910</code></pre>
</div>
</div>
<p>Looks good! You can check the other elements until you get used to the algorithm.</p>
<p>We multiplied a <span class="math inline">\(2 \times 3\)</span> matrix by a <span class="math inline">\(3 \times 4\)</span> matrix, so the result is a <span class="math inline">\(2 \times 4\)</span> matrix. The first matrix’s number of columns has to be equal to the second matrix’s number of rows. If we try to multiply <span class="math inline">\(D\)</span> by <span class="math inline">\(A\)</span>, we get an error because D has 4 columns while A has 2 rows:</p>
<div class="cell" data-execution_count="56">
<div class="sourceCode cell-code" id="cb99"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb99-1"><a href="#cb99-1" aria-hidden="true" tabindex="-1"></a><span class="cf">try</span>:</span>
<span id="cb99-2"><a href="#cb99-2" aria-hidden="true" tabindex="-1"></a>    D.dot(A)</span>
<span id="cb99-3"><a href="#cb99-3" aria-hidden="true" tabindex="-1"></a><span class="cf">except</span> <span class="pp">ValueError</span> <span class="im">as</span> e:</span>
<span id="cb99-4"><a href="#cb99-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"ValueError:"</span>, e)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>ValueError: shapes (3,4) and (2,3) not aligned: 4 (dim 1) != 2 (dim 0)</code></pre>
</div>
</div>
<p>This illustrates the fact that <strong>matrix multiplication is <em>NOT</em> commutative</strong>: in general <span class="math inline">\(QR ≠ RQ\)</span></p>
<p>In fact, <span class="math inline">\(QR\)</span> and <span class="math inline">\(RQ\)</span> are only <em>both</em> defined if <span class="math inline">\(Q\)</span> has size <span class="math inline">\(m \times n\)</span> and <span class="math inline">\(R\)</span> has size <span class="math inline">\(n \times m\)</span>. Let’s look at an example where both <em>are</em> defined and show that they are (in general) <em>NOT</em> equal:</p>
<div class="cell" data-execution_count="57">
<div class="sourceCode cell-code" id="cb101"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb101-1"><a href="#cb101-1" aria-hidden="true" tabindex="-1"></a>F <span class="op">=</span> np.array([</span>
<span id="cb101-2"><a href="#cb101-2" aria-hidden="true" tabindex="-1"></a>        [<span class="dv">5</span>,<span class="dv">2</span>],</span>
<span id="cb101-3"><a href="#cb101-3" aria-hidden="true" tabindex="-1"></a>        [<span class="dv">4</span>,<span class="dv">1</span>],</span>
<span id="cb101-4"><a href="#cb101-4" aria-hidden="true" tabindex="-1"></a>        [<span class="dv">9</span>,<span class="dv">3</span>]</span>
<span id="cb101-5"><a href="#cb101-5" aria-hidden="true" tabindex="-1"></a>    ])</span>
<span id="cb101-6"><a href="#cb101-6" aria-hidden="true" tabindex="-1"></a>A.dot(F)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="57">
<pre><code>array([[400, 130],
       [940, 310]])</code></pre>
</div>
</div>
<div class="cell" data-execution_count="58">
<div class="sourceCode cell-code" id="cb103"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true" tabindex="-1"></a>F.dot(A)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="58">
<pre><code>array([[130, 200, 270],
       [ 80, 130, 180],
       [210, 330, 450]])</code></pre>
</div>
</div>
<p>On the other hand, <strong>matrix multiplication <em>is</em> associative</strong>, meaning that <span class="math inline">\(Q(RS) = (QR)S\)</span>. Let’s create a <span class="math inline">\(4 \times 5\)</span> matrix <span class="math inline">\(G\)</span> to illustrate this:</p>
<div class="cell" data-execution_count="59">
<div class="sourceCode cell-code" id="cb105"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb105-1"><a href="#cb105-1" aria-hidden="true" tabindex="-1"></a>G <span class="op">=</span> np.array([</span>
<span id="cb105-2"><a href="#cb105-2" aria-hidden="true" tabindex="-1"></a>        [<span class="dv">8</span>,  <span class="dv">7</span>,  <span class="dv">4</span>,  <span class="dv">2</span>,  <span class="dv">5</span>],</span>
<span id="cb105-3"><a href="#cb105-3" aria-hidden="true" tabindex="-1"></a>        [<span class="dv">2</span>,  <span class="dv">5</span>,  <span class="dv">1</span>,  <span class="dv">0</span>,  <span class="dv">5</span>],</span>
<span id="cb105-4"><a href="#cb105-4" aria-hidden="true" tabindex="-1"></a>        [<span class="dv">9</span>, <span class="dv">11</span>, <span class="dv">17</span>, <span class="dv">21</span>,  <span class="dv">0</span>],</span>
<span id="cb105-5"><a href="#cb105-5" aria-hidden="true" tabindex="-1"></a>        [<span class="dv">0</span>,  <span class="dv">1</span>,  <span class="dv">0</span>,  <span class="dv">1</span>,  <span class="dv">2</span>]])</span>
<span id="cb105-6"><a href="#cb105-6" aria-hidden="true" tabindex="-1"></a>A.dot(D).dot(G)     <span class="co"># (AB)G</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="59">
<pre><code>array([[21640, 28390, 27320, 31140, 13570],
       [47290, 62080, 60020, 68580, 29500]])</code></pre>
</div>
</div>
<div class="cell" data-execution_count="60">
<div class="sourceCode cell-code" id="cb107"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb107-1"><a href="#cb107-1" aria-hidden="true" tabindex="-1"></a>A.dot(D.dot(G))     <span class="co"># A(BG)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="60">
<pre><code>array([[21640, 28390, 27320, 31140, 13570],
       [47290, 62080, 60020, 68580, 29500]])</code></pre>
</div>
</div>
<p>It is also <strong><em>distributive</em> over addition</strong> of matrices, meaning that <span class="math inline">\((Q + R)S = QS + RS\)</span>. For example:</p>
<div class="cell" data-execution_count="61">
<div class="sourceCode cell-code" id="cb109"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb109-1"><a href="#cb109-1" aria-hidden="true" tabindex="-1"></a>(A <span class="op">+</span> B).dot(D)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="61">
<pre><code>array([[1023, 1276, 1452, 1716],
       [2211, 2761, 3201, 3795]])</code></pre>
</div>
</div>
<div class="cell" data-execution_count="62">
<div class="sourceCode cell-code" id="cb111"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb111-1"><a href="#cb111-1" aria-hidden="true" tabindex="-1"></a>A.dot(D) <span class="op">+</span> B.dot(D)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="62">
<pre><code>array([[1023, 1276, 1452, 1716],
       [2211, 2761, 3201, 3795]])</code></pre>
</div>
</div>
<p>The product of a matrix <span class="math inline">\(M\)</span> by the identity matrix (of matching size) results in the same matrix <span class="math inline">\(M\)</span>. More formally, if <span class="math inline">\(M\)</span> is an <span class="math inline">\(m \times n\)</span> matrix, then:</p>
<p><span class="math inline">\(M I_n = I_m M = M\)</span></p>
<p>This is generally written more concisely (since the size of the identity matrices is unambiguous given the context):</p>
<p><span class="math inline">\(MI = IM = M\)</span></p>
<p>For example:</p>
<div class="cell" data-execution_count="63">
<div class="sourceCode cell-code" id="cb113"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb113-1"><a href="#cb113-1" aria-hidden="true" tabindex="-1"></a>A.dot(np.eye(<span class="dv">3</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="63">
<pre><code>array([[ 10.,  20.,  30.],
       [ 40.,  50.,  60.]])</code></pre>
</div>
</div>
<div class="cell" data-execution_count="64">
<div class="sourceCode cell-code" id="cb115"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb115-1"><a href="#cb115-1" aria-hidden="true" tabindex="-1"></a>np.eye(<span class="dv">2</span>).dot(A)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="64">
<pre><code>array([[ 10.,  20.,  30.],
       [ 40.,  50.,  60.]])</code></pre>
</div>
</div>
<p><strong>Caution</strong>: NumPy’s <code>*</code> operator performs elementwise multiplication, <em>NOT</em> a matrix multiplication:</p>
<div class="cell" data-scrolled="true" data-execution_count="65">
<div class="sourceCode cell-code" id="cb117"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb117-1"><a href="#cb117-1" aria-hidden="true" tabindex="-1"></a>A <span class="op">*</span> B   <span class="co"># NOT a matrix multiplication</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="65">
<pre><code>array([[ 10,  40,  90],
       [160, 250, 360]])</code></pre>
</div>
</div>
<p><strong>The @ infix operator</strong></p>
<p>Python 3.5 <a href="https://docs.python.org/3/whatsnew/3.5.html#pep-465-a-dedicated-infix-operator-for-matrix-multiplication">introduced</a> the <code>@</code> infix operator for matrix multiplication, and NumPy 1.10 added support for it. If you are using Python 3.5+ and NumPy 1.10+, you can simply write <code>A @ D</code> instead of <code>A.dot(D)</code>, making your code much more readable (but less portable). This operator also works for vector dot products.</p>
<div class="cell" data-execution_count="66">
<div class="sourceCode cell-code" id="cb119"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb119-1"><a href="#cb119-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> sys</span>
<span id="cb119-2"><a href="#cb119-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Python version: </span><span class="sc">{}</span><span class="st">.</span><span class="sc">{}</span><span class="st">.</span><span class="sc">{}</span><span class="st">"</span>.<span class="bu">format</span>(<span class="op">*</span>sys.version_info))</span>
<span id="cb119-3"><a href="#cb119-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Numpy version:"</span>, np.version.version)</span>
<span id="cb119-4"><a href="#cb119-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb119-5"><a href="#cb119-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Uncomment the following line if your Python version is ≥3.5</span></span>
<span id="cb119-6"><a href="#cb119-6" aria-hidden="true" tabindex="-1"></a><span class="co"># and your NumPy version is ≥1.10:</span></span>
<span id="cb119-7"><a href="#cb119-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb119-8"><a href="#cb119-8" aria-hidden="true" tabindex="-1"></a><span class="co">#A @ D</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Python version: 3.5.3
Numpy version: 1.12.1</code></pre>
</div>
</div>
<p>Note: <code>Q @ R</code> is actually equivalent to <code>Q.__matmul__(R)</code> which is implemented by NumPy as <code>np.matmul(Q, R)</code>, not as <code>Q.dot(R)</code>. The main difference is that <code>matmul</code> does not support scalar multiplication, while <code>dot</code> does, so you can write <code>Q.dot(3)</code>, which is equivalent to <code>Q * 3</code>, but you cannot write <code>Q @ 3</code> (<a href="http://stackoverflow.com/a/34142617/38626">more details</a>).</p>
</section>
<section id="matrix-transpose" class="level2">
<h2 class="anchored" data-anchor-id="matrix-transpose">Matrix transpose</h2>
<p>The transpose of a matrix <span class="math inline">\(M\)</span> is a matrix noted <span class="math inline">\(M^T\)</span> such that the <span class="math inline">\(i^{th}\)</span> row in <span class="math inline">\(M^T\)</span> is equal to the <span class="math inline">\(i^{th}\)</span> column in <span class="math inline">\(M\)</span>:</p>
$ A^T =
<span class="math display">\[\begin{bmatrix}
  10 &amp; 20 &amp; 30 \\
  40 &amp; 50 &amp; 60
\end{bmatrix}\]</span>
^T =
<span class="math display">\[\begin{bmatrix}
  10 &amp; 40 \\
  20 &amp; 50 \\
  30 &amp; 60
\end{bmatrix}\]</span>
<p>$</p>
<p>In other words, (<span class="math inline">\(A^T)_{i,j}\)</span> = <span class="math inline">\(A_{j,i}\)</span></p>
<p>Obviously, if <span class="math inline">\(M\)</span> is an <span class="math inline">\(m \times n\)</span> matrix, then <span class="math inline">\(M^T\)</span> is an <span class="math inline">\(n \times m\)</span> matrix.</p>
<p>Note: there are a few other notations, such as <span class="math inline">\(M^t\)</span>, <span class="math inline">\(M′\)</span>, or <span class="math inline">\({^t}M\)</span>.</p>
<p>In NumPy, a matrix’s transpose can be obtained simply using the <code>T</code> attribute:</p>
<div class="cell" data-execution_count="67">
<div class="sourceCode cell-code" id="cb121"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb121-1"><a href="#cb121-1" aria-hidden="true" tabindex="-1"></a>A</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="67">
<pre><code>array([[10, 20, 30],
       [40, 50, 60]])</code></pre>
</div>
</div>
<div class="cell" data-execution_count="68">
<div class="sourceCode cell-code" id="cb123"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb123-1"><a href="#cb123-1" aria-hidden="true" tabindex="-1"></a>A.T</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="68">
<pre><code>array([[10, 40],
       [20, 50],
       [30, 60]])</code></pre>
</div>
</div>
<p>As you might expect, transposing a matrix twice returns the original matrix:</p>
<div class="cell" data-execution_count="69">
<div class="sourceCode cell-code" id="cb125"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb125-1"><a href="#cb125-1" aria-hidden="true" tabindex="-1"></a>A.T.T</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="69">
<pre><code>array([[10, 20, 30],
       [40, 50, 60]])</code></pre>
</div>
</div>
<p>Transposition is distributive over addition of matrices, meaning that <span class="math inline">\((Q + R)^T = Q^T + R^T\)</span>. For example:</p>
<div class="cell" data-execution_count="70">
<div class="sourceCode cell-code" id="cb127"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb127-1"><a href="#cb127-1" aria-hidden="true" tabindex="-1"></a>(A <span class="op">+</span> B).T</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="70">
<pre><code>array([[11, 44],
       [22, 55],
       [33, 66]])</code></pre>
</div>
</div>
<div class="cell" data-execution_count="71">
<div class="sourceCode cell-code" id="cb129"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb129-1"><a href="#cb129-1" aria-hidden="true" tabindex="-1"></a>A.T <span class="op">+</span> B.T</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="71">
<pre><code>array([[11, 44],
       [22, 55],
       [33, 66]])</code></pre>
</div>
</div>
<p>Moreover, <span class="math inline">\((Q \cdot R)^T = R^T \cdot Q^T\)</span>. Note that the order is reversed. For example:</p>
<div class="cell" data-execution_count="72">
<div class="sourceCode cell-code" id="cb131"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb131-1"><a href="#cb131-1" aria-hidden="true" tabindex="-1"></a>(A.dot(D)).T</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="72">
<pre><code>array([[ 930, 2010],
       [1160, 2510],
       [1320, 2910],
       [1560, 3450]])</code></pre>
</div>
</div>
<div class="cell" data-execution_count="73">
<div class="sourceCode cell-code" id="cb133"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb133-1"><a href="#cb133-1" aria-hidden="true" tabindex="-1"></a>D.T.dot(A.T)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="73">
<pre><code>array([[ 930, 2010],
       [1160, 2510],
       [1320, 2910],
       [1560, 3450]])</code></pre>
</div>
</div>
<p>A <strong>symmetric matrix</strong> <span class="math inline">\(M\)</span> is defined as a matrix that is equal to its transpose: <span class="math inline">\(M^T = M\)</span>. This definition implies that it must be a square matrix whose elements are symmetric relative to the main diagonal, for example:</p>
<span class="math display">\[\begin{bmatrix}
  17 &amp; 22 &amp; 27 &amp; 49 \\
  22 &amp; 29 &amp; 36 &amp; 0 \\
  27 &amp; 36 &amp; 45 &amp; 2 \\
  49 &amp; 0 &amp; 2 &amp; 99
\end{bmatrix}\]</span>
<p>The product of a matrix by its transpose is always a symmetric matrix, for example:</p>
<div class="cell" data-execution_count="74">
<div class="sourceCode cell-code" id="cb135"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb135-1"><a href="#cb135-1" aria-hidden="true" tabindex="-1"></a>D.dot(D.T)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="74">
<pre><code>array([[  87,  279,  547],
       [ 279,  940, 1860],
       [ 547, 1860, 3700]])</code></pre>
</div>
</div>
</section>
<section id="converting-1d-arrays-to-2d-arrays-in-numpy" class="level2">
<h2 class="anchored" data-anchor-id="converting-1d-arrays-to-2d-arrays-in-numpy">Converting 1D arrays to 2D arrays in NumPy</h2>
<p>As we mentionned earlier, in NumPy (as opposed to Matlab, for example), 1D really means 1D: there is no such thing as a vertical 1D-array or a horizontal 1D-array. So you should not be surprised to see that transposing a 1D array does not do anything:</p>
<div class="cell" data-execution_count="75">
<div class="sourceCode cell-code" id="cb137"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb137-1"><a href="#cb137-1" aria-hidden="true" tabindex="-1"></a>u</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="75">
<pre><code>array([2, 5])</code></pre>
</div>
</div>
<div class="cell" data-execution_count="76">
<div class="sourceCode cell-code" id="cb139"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb139-1"><a href="#cb139-1" aria-hidden="true" tabindex="-1"></a>u.T</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="76">
<pre><code>array([2, 5])</code></pre>
</div>
</div>
<p>We want to convert <span class="math inline">\(\textbf{u}\)</span> into a row vector before transposing it. There are a few ways to do this:</p>
<div class="cell" data-execution_count="77">
<div class="sourceCode cell-code" id="cb141"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb141-1"><a href="#cb141-1" aria-hidden="true" tabindex="-1"></a>u_row <span class="op">=</span> np.array([u])</span>
<span id="cb141-2"><a href="#cb141-2" aria-hidden="true" tabindex="-1"></a>u_row</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="77">
<pre><code>array([[2, 5]])</code></pre>
</div>
</div>
<p>Notice the extra square brackets: this is a 2D array with just one row (ie. a 1x2 matrix). In other words it really is a <strong>row vector</strong>.</p>
<div class="cell" data-execution_count="78">
<div class="sourceCode cell-code" id="cb143"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb143-1"><a href="#cb143-1" aria-hidden="true" tabindex="-1"></a>u[np.newaxis, :]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="78">
<pre><code>array([[2, 5]])</code></pre>
</div>
</div>
<p>This is quite explicit: we are asking for a new vertical axis, keeping the existing data as the horizontal axis.</p>
<div class="cell" data-execution_count="79">
<div class="sourceCode cell-code" id="cb145"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb145-1"><a href="#cb145-1" aria-hidden="true" tabindex="-1"></a>u[np.newaxis]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="79">
<pre><code>array([[2, 5]])</code></pre>
</div>
</div>
<p>This is equivalent, but a little less explicit.</p>
<div class="cell" data-execution_count="80">
<div class="sourceCode cell-code" id="cb147"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb147-1"><a href="#cb147-1" aria-hidden="true" tabindex="-1"></a>u[<span class="va">None</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="80">
<pre><code>array([[2, 5]])</code></pre>
</div>
</div>
<p>This is the shortest version, but you probably want to avoid it because it is unclear. The reason it works is that <code>np.newaxis</code> is actually equal to <code>None</code>, so this is equivalent to the previous version.</p>
<p>Ok, now let’s transpose our row vector:</p>
<div class="cell" data-execution_count="81">
<div class="sourceCode cell-code" id="cb149"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb149-1"><a href="#cb149-1" aria-hidden="true" tabindex="-1"></a>u_row.T</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="81">
<pre><code>array([[2],
       [5]])</code></pre>
</div>
</div>
<p>Great! We now have a nice <strong>column vector</strong>.</p>
<p>Rather than creating a row vector then transposing it, it is also possible to convert a 1D array directly into a column vector:</p>
<div class="cell" data-execution_count="82">
<div class="sourceCode cell-code" id="cb151"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb151-1"><a href="#cb151-1" aria-hidden="true" tabindex="-1"></a>u[:, np.newaxis]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="82">
<pre><code>array([[2],
       [5]])</code></pre>
</div>
</div>
</section>
<section id="plotting-a-matrix" class="level2">
<h2 class="anchored" data-anchor-id="plotting-a-matrix">Plotting a matrix</h2>
<p>We have already seen that vectors can be represented as points or arrows in N-dimensional space. Is there a good graphical representation of matrices? Well you can simply see a matrix as a list of vectors, so plotting a matrix results in many points or arrows. For example, let’s create a <span class="math inline">\(2 \times 4\)</span> matrix <code>P</code> and plot it as points:</p>
<div class="cell" data-execution_count="83">
<div class="sourceCode cell-code" id="cb153"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb153-1"><a href="#cb153-1" aria-hidden="true" tabindex="-1"></a>P <span class="op">=</span> np.array([</span>
<span id="cb153-2"><a href="#cb153-2" aria-hidden="true" tabindex="-1"></a>        [<span class="fl">3.0</span>, <span class="fl">4.0</span>, <span class="fl">1.0</span>, <span class="fl">4.6</span>],</span>
<span id="cb153-3"><a href="#cb153-3" aria-hidden="true" tabindex="-1"></a>        [<span class="fl">0.2</span>, <span class="fl">3.5</span>, <span class="fl">2.0</span>, <span class="fl">0.5</span>]</span>
<span id="cb153-4"><a href="#cb153-4" aria-hidden="true" tabindex="-1"></a>    ])</span>
<span id="cb153-5"><a href="#cb153-5" aria-hidden="true" tabindex="-1"></a>x_coords_P, y_coords_P <span class="op">=</span> P</span>
<span id="cb153-6"><a href="#cb153-6" aria-hidden="true" tabindex="-1"></a>plt.scatter(x_coords_P, y_coords_P)</span>
<span id="cb153-7"><a href="#cb153-7" aria-hidden="true" tabindex="-1"></a>plt.axis([<span class="dv">0</span>, <span class="dv">5</span>, <span class="dv">0</span>, <span class="dv">4</span>])</span>
<span id="cb153-8"><a href="#cb153-8" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="math_linear_algebra_files/figure-html/cell-83-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>Of course we could also have stored the same 4 vectors as row vectors instead of column vectors, resulting in a <span class="math inline">\(4 \times 2\)</span> matrix (the transpose of <span class="math inline">\(P\)</span>, in fact). It is really an arbitrary choice.</p>
<p>Since the vectors are ordered, you can see the matrix as a path and represent it with connected dots:</p>
<div class="cell" data-execution_count="84">
<div class="sourceCode cell-code" id="cb154"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb154-1"><a href="#cb154-1" aria-hidden="true" tabindex="-1"></a>plt.plot(x_coords_P, y_coords_P, <span class="st">"bo"</span>)</span>
<span id="cb154-2"><a href="#cb154-2" aria-hidden="true" tabindex="-1"></a>plt.plot(x_coords_P, y_coords_P, <span class="st">"b--"</span>)</span>
<span id="cb154-3"><a href="#cb154-3" aria-hidden="true" tabindex="-1"></a>plt.axis([<span class="dv">0</span>, <span class="dv">5</span>, <span class="dv">0</span>, <span class="dv">4</span>])</span>
<span id="cb154-4"><a href="#cb154-4" aria-hidden="true" tabindex="-1"></a>plt.grid()</span>
<span id="cb154-5"><a href="#cb154-5" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="math_linear_algebra_files/figure-html/cell-84-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>Or you can represent it as a polygon: matplotlib’s <code>Polygon</code> class expects an <span class="math inline">\(n \times 2\)</span> NumPy array, not a <span class="math inline">\(2 \times n\)</span> array, so we just need to give it <span class="math inline">\(P^T\)</span>:</p>
<div class="cell" data-execution_count="85">
<div class="sourceCode cell-code" id="cb155"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb155-1"><a href="#cb155-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> matplotlib.patches <span class="im">import</span> Polygon</span>
<span id="cb155-2"><a href="#cb155-2" aria-hidden="true" tabindex="-1"></a>plt.gca().add_artist(Polygon(P.T))</span>
<span id="cb155-3"><a href="#cb155-3" aria-hidden="true" tabindex="-1"></a>plt.axis([<span class="dv">0</span>, <span class="dv">5</span>, <span class="dv">0</span>, <span class="dv">4</span>])</span>
<span id="cb155-4"><a href="#cb155-4" aria-hidden="true" tabindex="-1"></a>plt.grid()</span>
<span id="cb155-5"><a href="#cb155-5" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="math_linear_algebra_files/figure-html/cell-85-output-1.png" class="img-fluid"></p>
</div>
</div>
</section>
<section id="geometric-applications-of-matrix-operations" class="level2">
<h2 class="anchored" data-anchor-id="geometric-applications-of-matrix-operations">Geometric applications of matrix operations</h2>
<p>We saw earlier that vector addition results in a geometric translation, vector multiplication by a scalar results in rescaling (zooming in or out, centered on the origin), and vector dot product results in projecting a vector onto another vector, rescaling and measuring the resulting coordinate.</p>
<p>Similarly, matrix operations have very useful geometric applications.</p>
<section id="addition-multiple-geometric-translations" class="level3">
<h3 class="anchored" data-anchor-id="addition-multiple-geometric-translations">Addition = multiple geometric translations</h3>
<p>First, adding two matrices together is equivalent to adding all their vectors together. For example, let’s create a <span class="math inline">\(2 \times 4\)</span> matrix <span class="math inline">\(H\)</span> and add it to <span class="math inline">\(P\)</span>, and look at the result:</p>
<div class="cell" data-execution_count="86">
<div class="sourceCode cell-code" id="cb156"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb156-1"><a href="#cb156-1" aria-hidden="true" tabindex="-1"></a>H <span class="op">=</span> np.array([</span>
<span id="cb156-2"><a href="#cb156-2" aria-hidden="true" tabindex="-1"></a>        [ <span class="fl">0.5</span>, <span class="op">-</span><span class="fl">0.2</span>, <span class="fl">0.2</span>, <span class="op">-</span><span class="fl">0.1</span>],</span>
<span id="cb156-3"><a href="#cb156-3" aria-hidden="true" tabindex="-1"></a>        [ <span class="fl">0.4</span>,  <span class="fl">0.4</span>, <span class="fl">1.5</span>, <span class="fl">0.6</span>]</span>
<span id="cb156-4"><a href="#cb156-4" aria-hidden="true" tabindex="-1"></a>    ])</span>
<span id="cb156-5"><a href="#cb156-5" aria-hidden="true" tabindex="-1"></a>P_moved <span class="op">=</span> P <span class="op">+</span> H</span>
<span id="cb156-6"><a href="#cb156-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb156-7"><a href="#cb156-7" aria-hidden="true" tabindex="-1"></a>plt.gca().add_artist(Polygon(P.T, alpha<span class="op">=</span><span class="fl">0.2</span>))</span>
<span id="cb156-8"><a href="#cb156-8" aria-hidden="true" tabindex="-1"></a>plt.gca().add_artist(Polygon(P_moved.T, alpha<span class="op">=</span><span class="fl">0.3</span>, color<span class="op">=</span><span class="st">"r"</span>))</span>
<span id="cb156-9"><a href="#cb156-9" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> vector, origin <span class="kw">in</span> <span class="bu">zip</span>(H.T, P.T):</span>
<span id="cb156-10"><a href="#cb156-10" aria-hidden="true" tabindex="-1"></a>    plot_vector2d(vector, origin<span class="op">=</span>origin)</span>
<span id="cb156-11"><a href="#cb156-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb156-12"><a href="#cb156-12" aria-hidden="true" tabindex="-1"></a>plt.text(<span class="fl">2.2</span>, <span class="fl">1.8</span>, <span class="st">"$P$"</span>, color<span class="op">=</span><span class="st">"b"</span>, fontsize<span class="op">=</span><span class="dv">18</span>)</span>
<span id="cb156-13"><a href="#cb156-13" aria-hidden="true" tabindex="-1"></a>plt.text(<span class="fl">2.0</span>, <span class="fl">3.2</span>, <span class="st">"$P+H$"</span>, color<span class="op">=</span><span class="st">"r"</span>, fontsize<span class="op">=</span><span class="dv">18</span>)</span>
<span id="cb156-14"><a href="#cb156-14" aria-hidden="true" tabindex="-1"></a>plt.text(<span class="fl">2.5</span>, <span class="fl">0.5</span>, <span class="st">"$H_{*,1}$"</span>, color<span class="op">=</span><span class="st">"k"</span>, fontsize<span class="op">=</span><span class="dv">18</span>)</span>
<span id="cb156-15"><a href="#cb156-15" aria-hidden="true" tabindex="-1"></a>plt.text(<span class="fl">4.1</span>, <span class="fl">3.5</span>, <span class="st">"$H_{*,2}$"</span>, color<span class="op">=</span><span class="st">"k"</span>, fontsize<span class="op">=</span><span class="dv">18</span>)</span>
<span id="cb156-16"><a href="#cb156-16" aria-hidden="true" tabindex="-1"></a>plt.text(<span class="fl">0.4</span>, <span class="fl">2.6</span>, <span class="st">"$H_{*,3}$"</span>, color<span class="op">=</span><span class="st">"k"</span>, fontsize<span class="op">=</span><span class="dv">18</span>)</span>
<span id="cb156-17"><a href="#cb156-17" aria-hidden="true" tabindex="-1"></a>plt.text(<span class="fl">4.4</span>, <span class="fl">0.2</span>, <span class="st">"$H_{*,4}$"</span>, color<span class="op">=</span><span class="st">"k"</span>, fontsize<span class="op">=</span><span class="dv">18</span>)</span>
<span id="cb156-18"><a href="#cb156-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb156-19"><a href="#cb156-19" aria-hidden="true" tabindex="-1"></a>plt.axis([<span class="dv">0</span>, <span class="dv">5</span>, <span class="dv">0</span>, <span class="dv">4</span>])</span>
<span id="cb156-20"><a href="#cb156-20" aria-hidden="true" tabindex="-1"></a>plt.grid()</span>
<span id="cb156-21"><a href="#cb156-21" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="math_linear_algebra_files/figure-html/cell-86-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>If we add a matrix full of identical vectors, we get a simple geometric translation:</p>
<div class="cell" data-execution_count="87">
<div class="sourceCode cell-code" id="cb157"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb157-1"><a href="#cb157-1" aria-hidden="true" tabindex="-1"></a>H2 <span class="op">=</span> np.array([</span>
<span id="cb157-2"><a href="#cb157-2" aria-hidden="true" tabindex="-1"></a>        [<span class="op">-</span><span class="fl">0.5</span>, <span class="op">-</span><span class="fl">0.5</span>, <span class="op">-</span><span class="fl">0.5</span>, <span class="op">-</span><span class="fl">0.5</span>],</span>
<span id="cb157-3"><a href="#cb157-3" aria-hidden="true" tabindex="-1"></a>        [ <span class="fl">0.4</span>,  <span class="fl">0.4</span>,  <span class="fl">0.4</span>,  <span class="fl">0.4</span>]</span>
<span id="cb157-4"><a href="#cb157-4" aria-hidden="true" tabindex="-1"></a>    ])</span>
<span id="cb157-5"><a href="#cb157-5" aria-hidden="true" tabindex="-1"></a>P_translated <span class="op">=</span> P <span class="op">+</span> H2</span>
<span id="cb157-6"><a href="#cb157-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb157-7"><a href="#cb157-7" aria-hidden="true" tabindex="-1"></a>plt.gca().add_artist(Polygon(P.T, alpha<span class="op">=</span><span class="fl">0.2</span>))</span>
<span id="cb157-8"><a href="#cb157-8" aria-hidden="true" tabindex="-1"></a>plt.gca().add_artist(Polygon(P_translated.T, alpha<span class="op">=</span><span class="fl">0.3</span>, color<span class="op">=</span><span class="st">"r"</span>))</span>
<span id="cb157-9"><a href="#cb157-9" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> vector, origin <span class="kw">in</span> <span class="bu">zip</span>(H2.T, P.T):</span>
<span id="cb157-10"><a href="#cb157-10" aria-hidden="true" tabindex="-1"></a>    plot_vector2d(vector, origin<span class="op">=</span>origin)</span>
<span id="cb157-11"><a href="#cb157-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb157-12"><a href="#cb157-12" aria-hidden="true" tabindex="-1"></a>plt.axis([<span class="dv">0</span>, <span class="dv">5</span>, <span class="dv">0</span>, <span class="dv">4</span>])</span>
<span id="cb157-13"><a href="#cb157-13" aria-hidden="true" tabindex="-1"></a>plt.grid()</span>
<span id="cb157-14"><a href="#cb157-14" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="math_linear_algebra_files/figure-html/cell-87-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>Although matrices can only be added together if they have the same size, NumPy allows adding a row vector or a column vector to a matrix: this is called <em>broadcasting</em> and is explained in further details in the <a href="tools_numpy.ipynb">NumPy tutorial</a>. We could have obtained the same result as above with:</p>
<div class="cell" data-execution_count="88">
<div class="sourceCode cell-code" id="cb158"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb158-1"><a href="#cb158-1" aria-hidden="true" tabindex="-1"></a>P <span class="op">+</span> [[<span class="op">-</span><span class="fl">0.5</span>], [<span class="fl">0.4</span>]]  <span class="co"># same as P + H2, thanks to NumPy broadcasting</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="88">
<pre><code>array([[ 2.5,  3.5,  0.5,  4.1],
       [ 0.6,  3.9,  2.4,  0.9]])</code></pre>
</div>
</div>
</section>
<section id="scalar-multiplication-1" class="level3">
<h3 class="anchored" data-anchor-id="scalar-multiplication-1">Scalar multiplication</h3>
<p>Multiplying a matrix by a scalar results in all its vectors being multiplied by that scalar, so unsurprisingly, the geometric result is a rescaling of the entire figure. For example, let’s rescale our polygon by a factor of 60% (zooming out, centered on the origin):</p>
<div class="cell" data-execution_count="89">
<div class="sourceCode cell-code" id="cb160"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb160-1"><a href="#cb160-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> plot_transformation(P_before, P_after, text_before, text_after, axis <span class="op">=</span> [<span class="dv">0</span>, <span class="dv">5</span>, <span class="dv">0</span>, <span class="dv">4</span>], arrows<span class="op">=</span><span class="va">False</span>):</span>
<span id="cb160-2"><a href="#cb160-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> arrows:</span>
<span id="cb160-3"><a href="#cb160-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> vector_before, vector_after <span class="kw">in</span> <span class="bu">zip</span>(P_before.T, P_after.T):</span>
<span id="cb160-4"><a href="#cb160-4" aria-hidden="true" tabindex="-1"></a>            plot_vector2d(vector_before, color<span class="op">=</span><span class="st">"blue"</span>, linestyle<span class="op">=</span><span class="st">"--"</span>)</span>
<span id="cb160-5"><a href="#cb160-5" aria-hidden="true" tabindex="-1"></a>            plot_vector2d(vector_after, color<span class="op">=</span><span class="st">"red"</span>, linestyle<span class="op">=</span><span class="st">"-"</span>)</span>
<span id="cb160-6"><a href="#cb160-6" aria-hidden="true" tabindex="-1"></a>    plt.gca().add_artist(Polygon(P_before.T, alpha<span class="op">=</span><span class="fl">0.2</span>))</span>
<span id="cb160-7"><a href="#cb160-7" aria-hidden="true" tabindex="-1"></a>    plt.gca().add_artist(Polygon(P_after.T, alpha<span class="op">=</span><span class="fl">0.3</span>, color<span class="op">=</span><span class="st">"r"</span>))</span>
<span id="cb160-8"><a href="#cb160-8" aria-hidden="true" tabindex="-1"></a>    plt.text(P_before[<span class="dv">0</span>].mean(), P_before[<span class="dv">1</span>].mean(), text_before, fontsize<span class="op">=</span><span class="dv">18</span>, color<span class="op">=</span><span class="st">"blue"</span>)</span>
<span id="cb160-9"><a href="#cb160-9" aria-hidden="true" tabindex="-1"></a>    plt.text(P_after[<span class="dv">0</span>].mean(), P_after[<span class="dv">1</span>].mean(), text_after, fontsize<span class="op">=</span><span class="dv">18</span>, color<span class="op">=</span><span class="st">"red"</span>)</span>
<span id="cb160-10"><a href="#cb160-10" aria-hidden="true" tabindex="-1"></a>    plt.axis(axis)</span>
<span id="cb160-11"><a href="#cb160-11" aria-hidden="true" tabindex="-1"></a>    plt.grid()</span>
<span id="cb160-12"><a href="#cb160-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb160-13"><a href="#cb160-13" aria-hidden="true" tabindex="-1"></a>P_rescaled <span class="op">=</span> <span class="fl">0.60</span> <span class="op">*</span> P</span>
<span id="cb160-14"><a href="#cb160-14" aria-hidden="true" tabindex="-1"></a>plot_transformation(P, P_rescaled, <span class="st">"$P$"</span>, <span class="st">"$0.6 P$"</span>, arrows<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb160-15"><a href="#cb160-15" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="math_linear_algebra_files/figure-html/cell-89-output-1.png" class="img-fluid"></p>
</div>
</div>
</section>
<section id="matrix-multiplication-projection-onto-an-axis" class="level3">
<h3 class="anchored" data-anchor-id="matrix-multiplication-projection-onto-an-axis">Matrix multiplication – Projection onto an axis</h3>
<p>Matrix multiplication is more complex to visualize, but it is also the most powerful tool in the box.</p>
<p>Let’s start simple, by defining a <span class="math inline">\(1 \times 2\)</span> matrix <span class="math inline">\(U = \begin{bmatrix} 1 &amp; 0 \end{bmatrix}\)</span>. This row vector is just the horizontal unit vector.</p>
<div class="cell" data-jupyter="{&quot;outputs_hidden&quot;:true}" data-execution_count="90">
<div class="sourceCode cell-code" id="cb161"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb161-1"><a href="#cb161-1" aria-hidden="true" tabindex="-1"></a>U <span class="op">=</span> np.array([[<span class="dv">1</span>, <span class="dv">0</span>]])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now let’s look at the dot product <span class="math inline">\(U \cdot P\)</span>:</p>
<div class="cell" data-execution_count="91">
<div class="sourceCode cell-code" id="cb162"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb162-1"><a href="#cb162-1" aria-hidden="true" tabindex="-1"></a>U.dot(P)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="91">
<pre><code>array([[ 3. ,  4. ,  1. ,  4.6]])</code></pre>
</div>
</div>
<p>These are the horizontal coordinates of the vectors in <span class="math inline">\(P\)</span>. In other words, we just projected <span class="math inline">\(P\)</span> onto the horizontal axis:</p>
<div class="cell" data-execution_count="92">
<div class="sourceCode cell-code" id="cb164"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb164-1"><a href="#cb164-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> plot_projection(U, P):</span>
<span id="cb164-2"><a href="#cb164-2" aria-hidden="true" tabindex="-1"></a>    U_P <span class="op">=</span> U.dot(P)</span>
<span id="cb164-3"><a href="#cb164-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb164-4"><a href="#cb164-4" aria-hidden="true" tabindex="-1"></a>    axis_end <span class="op">=</span> <span class="dv">100</span> <span class="op">*</span> U</span>
<span id="cb164-5"><a href="#cb164-5" aria-hidden="true" tabindex="-1"></a>    plot_vector2d(axis_end[<span class="dv">0</span>], color<span class="op">=</span><span class="st">"black"</span>)</span>
<span id="cb164-6"><a href="#cb164-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb164-7"><a href="#cb164-7" aria-hidden="true" tabindex="-1"></a>    plt.gca().add_artist(Polygon(P.T, alpha<span class="op">=</span><span class="fl">0.2</span>))</span>
<span id="cb164-8"><a href="#cb164-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> vector, proj_coordinate <span class="kw">in</span> <span class="bu">zip</span>(P.T, U_P.T):</span>
<span id="cb164-9"><a href="#cb164-9" aria-hidden="true" tabindex="-1"></a>        proj_point <span class="op">=</span> proj_coordinate <span class="op">*</span> U</span>
<span id="cb164-10"><a href="#cb164-10" aria-hidden="true" tabindex="-1"></a>        plt.plot(proj_point[<span class="dv">0</span>][<span class="dv">0</span>], proj_point[<span class="dv">0</span>][<span class="dv">1</span>], <span class="st">"ro"</span>)</span>
<span id="cb164-11"><a href="#cb164-11" aria-hidden="true" tabindex="-1"></a>        plt.plot([vector[<span class="dv">0</span>], proj_point[<span class="dv">0</span>][<span class="dv">0</span>]], [vector[<span class="dv">1</span>], proj_point[<span class="dv">0</span>][<span class="dv">1</span>]], <span class="st">"r--"</span>)</span>
<span id="cb164-12"><a href="#cb164-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb164-13"><a href="#cb164-13" aria-hidden="true" tabindex="-1"></a>    plt.axis([<span class="dv">0</span>, <span class="dv">5</span>, <span class="dv">0</span>, <span class="dv">4</span>])</span>
<span id="cb164-14"><a href="#cb164-14" aria-hidden="true" tabindex="-1"></a>    plt.grid()</span>
<span id="cb164-15"><a href="#cb164-15" aria-hidden="true" tabindex="-1"></a>    plt.show()</span>
<span id="cb164-16"><a href="#cb164-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb164-17"><a href="#cb164-17" aria-hidden="true" tabindex="-1"></a>plot_projection(U, P)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="math_linear_algebra_files/figure-html/cell-92-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>We can actually project on any other axis by just replacing <span class="math inline">\(U\)</span> with any other unit vector. For example, let’s project on the axis that is at a 30° angle above the horizontal axis:</p>
<div class="cell" data-execution_count="93">
<div class="sourceCode cell-code" id="cb165"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb165-1"><a href="#cb165-1" aria-hidden="true" tabindex="-1"></a>angle30 <span class="op">=</span> <span class="dv">30</span> <span class="op">*</span> np.pi <span class="op">/</span> <span class="dv">180</span>  <span class="co"># angle in radians</span></span>
<span id="cb165-2"><a href="#cb165-2" aria-hidden="true" tabindex="-1"></a>U_30 <span class="op">=</span> np.array([[np.cos(angle30), np.sin(angle30)]])</span>
<span id="cb165-3"><a href="#cb165-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb165-4"><a href="#cb165-4" aria-hidden="true" tabindex="-1"></a>plot_projection(U_30, P)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="math_linear_algebra_files/figure-html/cell-93-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>Good! Remember that the dot product of a unit vector and a matrix basically performs a projection on an axis and gives us the coordinates of the resulting points on that axis.</p>
</section>
<section id="matrix-multiplication-rotation" class="level3">
<h3 class="anchored" data-anchor-id="matrix-multiplication-rotation">Matrix multiplication – Rotation</h3>
<p>Now let’s create a <span class="math inline">\(2 \times 2\)</span> matrix <span class="math inline">\(V\)</span> containing two unit vectors that make 30° and 120° angles with the horizontal axis:</p>
<p><span class="math inline">\(V = \begin{bmatrix} \cos(30°) &amp; \sin(30°) \\ \cos(120°) &amp; \sin(120°) \end{bmatrix}\)</span></p>
<div class="cell" data-execution_count="94">
<div class="sourceCode cell-code" id="cb166"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb166-1"><a href="#cb166-1" aria-hidden="true" tabindex="-1"></a>angle120 <span class="op">=</span> <span class="dv">120</span> <span class="op">*</span> np.pi <span class="op">/</span> <span class="dv">180</span></span>
<span id="cb166-2"><a href="#cb166-2" aria-hidden="true" tabindex="-1"></a>V <span class="op">=</span> np.array([</span>
<span id="cb166-3"><a href="#cb166-3" aria-hidden="true" tabindex="-1"></a>        [np.cos(angle30), np.sin(angle30)],</span>
<span id="cb166-4"><a href="#cb166-4" aria-hidden="true" tabindex="-1"></a>        [np.cos(angle120), np.sin(angle120)]</span>
<span id="cb166-5"><a href="#cb166-5" aria-hidden="true" tabindex="-1"></a>    ])</span>
<span id="cb166-6"><a href="#cb166-6" aria-hidden="true" tabindex="-1"></a>V</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="94">
<pre><code>array([[ 0.8660254,  0.5      ],
       [-0.5      ,  0.8660254]])</code></pre>
</div>
</div>
<p>Let’s look at the product <span class="math inline">\(VP\)</span>:</p>
<div class="cell" data-execution_count="95">
<div class="sourceCode cell-code" id="cb168"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb168-1"><a href="#cb168-1" aria-hidden="true" tabindex="-1"></a>V.dot(P)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="95">
<pre><code>array([[ 2.69807621,  5.21410162,  1.8660254 ,  4.23371686],
       [-1.32679492,  1.03108891,  1.23205081, -1.8669873 ]])</code></pre>
</div>
</div>
<p>The first row is equal to <span class="math inline">\(V_{1,*} P\)</span>, which is the coordinates of the projection of <span class="math inline">\(P\)</span> onto the 30° axis, as we have seen above. The second row is <span class="math inline">\(V_{2,*} P\)</span>, which is the coordinates of the projection of <span class="math inline">\(P\)</span> onto the 120° axis. So basically we obtained the coordinates of <span class="math inline">\(P\)</span> after rotating the horizontal and vertical axes by 30° (or equivalently after rotating the polygon by -30° around the origin)! Let’s plot <span class="math inline">\(VP\)</span> to see this:</p>
<div class="cell" data-execution_count="96">
<div class="sourceCode cell-code" id="cb170"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb170-1"><a href="#cb170-1" aria-hidden="true" tabindex="-1"></a>P_rotated <span class="op">=</span> V.dot(P)</span>
<span id="cb170-2"><a href="#cb170-2" aria-hidden="true" tabindex="-1"></a>plot_transformation(P, P_rotated, <span class="st">"$P$"</span>, <span class="st">"$VP$"</span>, [<span class="op">-</span><span class="dv">2</span>, <span class="dv">6</span>, <span class="op">-</span><span class="dv">2</span>, <span class="dv">4</span>], arrows<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb170-3"><a href="#cb170-3" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="math_linear_algebra_files/figure-html/cell-96-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>Matrix <span class="math inline">\(V\)</span> is called a <strong>rotation matrix</strong>.</p>
</section>
<section id="matrix-multiplication-other-linear-transformations" class="level3">
<h3 class="anchored" data-anchor-id="matrix-multiplication-other-linear-transformations">Matrix multiplication – Other linear transformations</h3>
<p>More generally, any linear transformation <span class="math inline">\(f\)</span> that maps n-dimensional vectors to m-dimensional vectors can be represented as an <span class="math inline">\(m \times n\)</span> matrix. For example, say <span class="math inline">\(\textbf{u}\)</span> is a 3-dimensional vector:</p>
<p><span class="math inline">\(\textbf{u} = \begin{pmatrix} x \\ y \\ z \end{pmatrix}\)</span></p>
<p>and <span class="math inline">\(f\)</span> is defined as:</p>
<p><span class="math inline">\(f(\textbf{u}) = \begin{pmatrix} ax + by + cz \\ dx + ey + fz \end{pmatrix}\)</span></p>
<p>This transormation <span class="math inline">\(f\)</span> maps 3-dimensional vectors to 2-dimensional vectors in a linear way (ie. the resulting coordinates only involve sums of multiples of the original coordinates). We can represent this transformation as matrix <span class="math inline">\(F\)</span>:</p>
<p><span class="math inline">\(F = \begin{bmatrix} a &amp; b &amp; c \\ d &amp; e &amp; f \end{bmatrix}\)</span></p>
<p>Now, to compute <span class="math inline">\(f(\textbf{u})\)</span> we can simply do a matrix multiplication:</p>
<p><span class="math inline">\(f(\textbf{u}) = F \textbf{u}\)</span></p>
<p>If we have a matric <span class="math inline">\(G = \begin{bmatrix}\textbf{u}_1 &amp; \textbf{u}_2 &amp; \cdots &amp; \textbf{u}_q \end{bmatrix}\)</span>, where each <span class="math inline">\(\textbf{u}_i\)</span> is a 3-dimensional column vector, then <span class="math inline">\(FG\)</span> results in the linear transformation of all vectors <span class="math inline">\(\textbf{u}_i\)</span> as defined by the matrix <span class="math inline">\(F\)</span>:</p>
<p><span class="math inline">\(FG = \begin{bmatrix}f(\textbf{u}_1) &amp; f(\textbf{u}_2) &amp; \cdots &amp; f(\textbf{u}_q) \end{bmatrix}\)</span></p>
<p>To summarize, the matrix on the left hand side of a dot product specifies what linear transormation to apply to the right hand side vectors. We have already shown that this can be used to perform projections and rotations, but any other linear transformation is possible. For example, here is a transformation known as a <em>shear mapping</em>:</p>
<div class="cell" data-scrolled="true" data-execution_count="97">
<div class="sourceCode cell-code" id="cb171"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb171-1"><a href="#cb171-1" aria-hidden="true" tabindex="-1"></a>F_shear <span class="op">=</span> np.array([</span>
<span id="cb171-2"><a href="#cb171-2" aria-hidden="true" tabindex="-1"></a>        [<span class="dv">1</span>, <span class="fl">1.5</span>],</span>
<span id="cb171-3"><a href="#cb171-3" aria-hidden="true" tabindex="-1"></a>        [<span class="dv">0</span>, <span class="dv">1</span>]</span>
<span id="cb171-4"><a href="#cb171-4" aria-hidden="true" tabindex="-1"></a>    ])</span>
<span id="cb171-5"><a href="#cb171-5" aria-hidden="true" tabindex="-1"></a>plot_transformation(P, F_shear.dot(P), <span class="st">"$P$"</span>, <span class="st">"$F_</span><span class="sc">{shear}</span><span class="st"> P$"</span>,</span>
<span id="cb171-6"><a href="#cb171-6" aria-hidden="true" tabindex="-1"></a>                    axis<span class="op">=</span>[<span class="dv">0</span>, <span class="dv">10</span>, <span class="dv">0</span>, <span class="dv">7</span>])</span>
<span id="cb171-7"><a href="#cb171-7" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="math_linear_algebra_files/figure-html/cell-97-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>Let’s look at how this transformation affects the <strong>unit square</strong>:</p>
<div class="cell" data-execution_count="98">
<div class="sourceCode cell-code" id="cb172"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb172-1"><a href="#cb172-1" aria-hidden="true" tabindex="-1"></a>Square <span class="op">=</span> np.array([</span>
<span id="cb172-2"><a href="#cb172-2" aria-hidden="true" tabindex="-1"></a>        [<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>],</span>
<span id="cb172-3"><a href="#cb172-3" aria-hidden="true" tabindex="-1"></a>        [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>]</span>
<span id="cb172-4"><a href="#cb172-4" aria-hidden="true" tabindex="-1"></a>    ])</span>
<span id="cb172-5"><a href="#cb172-5" aria-hidden="true" tabindex="-1"></a>plot_transformation(Square, F_shear.dot(Square), <span class="st">"$Square$"</span>, <span class="st">"$F_</span><span class="sc">{shear}</span><span class="st"> Square$"</span>,</span>
<span id="cb172-6"><a href="#cb172-6" aria-hidden="true" tabindex="-1"></a>                    axis<span class="op">=</span>[<span class="dv">0</span>, <span class="fl">2.6</span>, <span class="dv">0</span>, <span class="fl">1.8</span>])</span>
<span id="cb172-7"><a href="#cb172-7" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="math_linear_algebra_files/figure-html/cell-98-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>Now let’s look at a <strong>squeeze mapping</strong>:</p>
<div class="cell" data-execution_count="99">
<div class="sourceCode cell-code" id="cb173"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb173-1"><a href="#cb173-1" aria-hidden="true" tabindex="-1"></a>F_squeeze <span class="op">=</span> np.array([</span>
<span id="cb173-2"><a href="#cb173-2" aria-hidden="true" tabindex="-1"></a>        [<span class="fl">1.4</span>, <span class="dv">0</span>],</span>
<span id="cb173-3"><a href="#cb173-3" aria-hidden="true" tabindex="-1"></a>        [<span class="dv">0</span>, <span class="dv">1</span><span class="op">/</span><span class="fl">1.4</span>]</span>
<span id="cb173-4"><a href="#cb173-4" aria-hidden="true" tabindex="-1"></a>    ])</span>
<span id="cb173-5"><a href="#cb173-5" aria-hidden="true" tabindex="-1"></a>plot_transformation(P, F_squeeze.dot(P), <span class="st">"$P$"</span>, <span class="st">"$F_</span><span class="sc">{squeeze}</span><span class="st"> P$"</span>,</span>
<span id="cb173-6"><a href="#cb173-6" aria-hidden="true" tabindex="-1"></a>                    axis<span class="op">=</span>[<span class="dv">0</span>, <span class="dv">7</span>, <span class="dv">0</span>, <span class="dv">5</span>])</span>
<span id="cb173-7"><a href="#cb173-7" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="math_linear_algebra_files/figure-html/cell-99-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>The effect on the unit square is:</p>
<div class="cell" data-execution_count="100">
<div class="sourceCode cell-code" id="cb174"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb174-1"><a href="#cb174-1" aria-hidden="true" tabindex="-1"></a>plot_transformation(Square, F_squeeze.dot(Square), <span class="st">"$Square$"</span>, <span class="st">"$F_</span><span class="sc">{squeeze}</span><span class="st"> Square$"</span>,</span>
<span id="cb174-2"><a href="#cb174-2" aria-hidden="true" tabindex="-1"></a>                    axis<span class="op">=</span>[<span class="dv">0</span>, <span class="fl">1.8</span>, <span class="dv">0</span>, <span class="fl">1.2</span>])</span>
<span id="cb174-3"><a href="#cb174-3" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="math_linear_algebra_files/figure-html/cell-100-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>Let’s show a last one: reflection through the horizontal axis:</p>
<div class="cell" data-execution_count="101">
<div class="sourceCode cell-code" id="cb175"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb175-1"><a href="#cb175-1" aria-hidden="true" tabindex="-1"></a>F_reflect <span class="op">=</span> np.array([</span>
<span id="cb175-2"><a href="#cb175-2" aria-hidden="true" tabindex="-1"></a>        [<span class="dv">1</span>, <span class="dv">0</span>],</span>
<span id="cb175-3"><a href="#cb175-3" aria-hidden="true" tabindex="-1"></a>        [<span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb175-4"><a href="#cb175-4" aria-hidden="true" tabindex="-1"></a>    ])</span>
<span id="cb175-5"><a href="#cb175-5" aria-hidden="true" tabindex="-1"></a>plot_transformation(P, F_reflect.dot(P), <span class="st">"$P$"</span>, <span class="st">"$F_</span><span class="sc">{reflect}</span><span class="st"> P$"</span>,</span>
<span id="cb175-6"><a href="#cb175-6" aria-hidden="true" tabindex="-1"></a>                    axis<span class="op">=</span>[<span class="op">-</span><span class="dv">2</span>, <span class="dv">9</span>, <span class="op">-</span><span class="fl">4.5</span>, <span class="fl">4.5</span>])</span>
<span id="cb175-7"><a href="#cb175-7" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="math_linear_algebra_files/figure-html/cell-101-output-1.png" class="img-fluid"></p>
</div>
</div>
</section>
</section>
<section id="matrix-inverse" class="level2">
<h2 class="anchored" data-anchor-id="matrix-inverse">Matrix inverse</h2>
<p>Now that we understand that a matrix can represent any linear transformation, a natural question is: can we find a transformation matrix that reverses the effect of a given transformation matrix <span class="math inline">\(F\)</span>? The answer is yes… sometimes! When it exists, such a matrix is called the <strong>inverse</strong> of <span class="math inline">\(F\)</span>, and it is noted <span class="math inline">\(F^{-1}\)</span>.</p>
<p>For example, the rotation, the shear mapping and the squeeze mapping above all have inverse transformations. Let’s demonstrate this on the shear mapping:</p>
<div class="cell" data-execution_count="102">
<div class="sourceCode cell-code" id="cb176"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb176-1"><a href="#cb176-1" aria-hidden="true" tabindex="-1"></a>F_inv_shear <span class="op">=</span> np.array([</span>
<span id="cb176-2"><a href="#cb176-2" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">1</span>, <span class="op">-</span><span class="fl">1.5</span>],</span>
<span id="cb176-3"><a href="#cb176-3" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">0</span>, <span class="dv">1</span>]</span>
<span id="cb176-4"><a href="#cb176-4" aria-hidden="true" tabindex="-1"></a>])</span>
<span id="cb176-5"><a href="#cb176-5" aria-hidden="true" tabindex="-1"></a>P_sheared <span class="op">=</span> F_shear.dot(P)</span>
<span id="cb176-6"><a href="#cb176-6" aria-hidden="true" tabindex="-1"></a>P_unsheared <span class="op">=</span> F_inv_shear.dot(P_sheared)</span>
<span id="cb176-7"><a href="#cb176-7" aria-hidden="true" tabindex="-1"></a>plot_transformation(P_sheared, P_unsheared, <span class="st">"$P_</span><span class="sc">{sheared}</span><span class="st">$"</span>, <span class="st">"$P_</span><span class="sc">{unsheared}</span><span class="st">$"</span>,</span>
<span id="cb176-8"><a href="#cb176-8" aria-hidden="true" tabindex="-1"></a>                    axis<span class="op">=</span>[<span class="dv">0</span>, <span class="dv">10</span>, <span class="dv">0</span>, <span class="dv">7</span>])</span>
<span id="cb176-9"><a href="#cb176-9" aria-hidden="true" tabindex="-1"></a>plt.plot(P[<span class="dv">0</span>], P[<span class="dv">1</span>], <span class="st">"b--"</span>)</span>
<span id="cb176-10"><a href="#cb176-10" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="math_linear_algebra_files/figure-html/cell-102-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>We applied a shear mapping on <span class="math inline">\(P\)</span>, just like we did before, but then we applied a second transformation to the result, and <em>lo and behold</em> this had the effect of coming back to the original <span class="math inline">\(P\)</span> (we plotted the original <span class="math inline">\(P\)</span>’s outline to double check). The second transformation is the inverse of the first one.</p>
<p>We defined the inverse matrix <span class="math inline">\(F_{shear}^{-1}\)</span> manually this time, but NumPy provides an <code>inv</code> function to compute a matrix’s inverse, so we could have written instead:</p>
<div class="cell" data-execution_count="103">
<div class="sourceCode cell-code" id="cb177"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb177-1"><a href="#cb177-1" aria-hidden="true" tabindex="-1"></a>F_inv_shear <span class="op">=</span> LA.inv(F_shear)</span>
<span id="cb177-2"><a href="#cb177-2" aria-hidden="true" tabindex="-1"></a>F_inv_shear</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="103">
<pre><code>array([[ 1. , -1.5],
       [ 0. ,  1. ]])</code></pre>
</div>
</div>
<p>Only square matrices can be inversed. This makes sense when you think about it: if you have a transformation that reduces the number of dimensions, then some information is lost and there is no way that you can get it back. For example say you use a <span class="math inline">\(2 \times 3\)</span> matrix to project a 3D object onto a plane. The result may look like this:</p>
<div class="cell" data-execution_count="104">
<div class="sourceCode cell-code" id="cb179"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb179-1"><a href="#cb179-1" aria-hidden="true" tabindex="-1"></a>plt.plot([<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="fl">0.1</span>, <span class="fl">0.1</span>, <span class="dv">0</span>, <span class="fl">0.1</span>, <span class="fl">1.1</span>, <span class="fl">1.0</span>, <span class="fl">1.1</span>, <span class="fl">1.1</span>, <span class="fl">1.0</span>, <span class="fl">1.1</span>, <span class="fl">0.1</span>],</span>
<span id="cb179-2"><a href="#cb179-2" aria-hidden="true" tabindex="-1"></a>         [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="fl">0.1</span>, <span class="fl">1.1</span>, <span class="fl">1.0</span>, <span class="fl">1.1</span>, <span class="fl">1.1</span>, <span class="fl">1.0</span>, <span class="fl">1.1</span>, <span class="fl">0.1</span>, <span class="dv">0</span>, <span class="fl">0.1</span>, <span class="fl">0.1</span>],</span>
<span id="cb179-3"><a href="#cb179-3" aria-hidden="true" tabindex="-1"></a>         <span class="st">"r-"</span>)</span>
<span id="cb179-4"><a href="#cb179-4" aria-hidden="true" tabindex="-1"></a>plt.axis([<span class="op">-</span><span class="fl">0.5</span>, <span class="fl">2.1</span>, <span class="op">-</span><span class="fl">0.5</span>, <span class="fl">1.5</span>])</span>
<span id="cb179-5"><a href="#cb179-5" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="math_linear_algebra_files/figure-html/cell-104-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>Looking at this image, it is impossible to tell whether this is the projection of a cube or the projection of a narrow rectangular object. Some information has been lost in the projection.</p>
<p>Even square transformation matrices can lose information. For example, consider this transformation matrix:</p>
<div class="cell" data-execution_count="105">
<div class="sourceCode cell-code" id="cb180"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb180-1"><a href="#cb180-1" aria-hidden="true" tabindex="-1"></a>F_project <span class="op">=</span> np.array([</span>
<span id="cb180-2"><a href="#cb180-2" aria-hidden="true" tabindex="-1"></a>        [<span class="dv">1</span>, <span class="dv">0</span>],</span>
<span id="cb180-3"><a href="#cb180-3" aria-hidden="true" tabindex="-1"></a>        [<span class="dv">0</span>, <span class="dv">0</span>]</span>
<span id="cb180-4"><a href="#cb180-4" aria-hidden="true" tabindex="-1"></a>    ])</span>
<span id="cb180-5"><a href="#cb180-5" aria-hidden="true" tabindex="-1"></a>plot_transformation(P, F_project.dot(P), <span class="st">"$P$"</span>, <span class="st">"$F_</span><span class="sc">{project}</span><span class="st"> \cdot P$"</span>,</span>
<span id="cb180-6"><a href="#cb180-6" aria-hidden="true" tabindex="-1"></a>                    axis<span class="op">=</span>[<span class="dv">0</span>, <span class="dv">6</span>, <span class="op">-</span><span class="dv">1</span>, <span class="dv">4</span>])</span>
<span id="cb180-7"><a href="#cb180-7" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="math_linear_algebra_files/figure-html/cell-105-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>This transformation matrix performs a projection onto the horizontal axis. Our polygon gets entirely flattened out so some information is entirely lost and it is impossible to go back to the original polygon using a linear transformation. In other words, <span class="math inline">\(F_{project}\)</span> has no inverse. Such a square matrix that cannot be inversed is called a <strong>singular matrix</strong> (aka degenerate matrix). If we ask NumPy to calculate its inverse, it raises an exception:</p>
<div class="cell" data-execution_count="106">
<div class="sourceCode cell-code" id="cb181"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb181-1"><a href="#cb181-1" aria-hidden="true" tabindex="-1"></a><span class="cf">try</span>:</span>
<span id="cb181-2"><a href="#cb181-2" aria-hidden="true" tabindex="-1"></a>    LA.inv(F_project)</span>
<span id="cb181-3"><a href="#cb181-3" aria-hidden="true" tabindex="-1"></a><span class="cf">except</span> LA.LinAlgError <span class="im">as</span> e:</span>
<span id="cb181-4"><a href="#cb181-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"LinAlgError:"</span>, e)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>LinAlgError: Singular matrix</code></pre>
</div>
</div>
<p>Here is another example of a singular matrix. This one performs a projection onto the axis at a 30° angle above the horizontal axis:</p>
<div class="cell" data-execution_count="107">
<div class="sourceCode cell-code" id="cb183"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb183-1"><a href="#cb183-1" aria-hidden="true" tabindex="-1"></a>angle30 <span class="op">=</span> <span class="dv">30</span> <span class="op">*</span> np.pi <span class="op">/</span> <span class="dv">180</span></span>
<span id="cb183-2"><a href="#cb183-2" aria-hidden="true" tabindex="-1"></a>F_project_30 <span class="op">=</span> np.array([</span>
<span id="cb183-3"><a href="#cb183-3" aria-hidden="true" tabindex="-1"></a>               [np.cos(angle30)<span class="op">**</span><span class="dv">2</span>, np.sin(<span class="dv">2</span><span class="op">*</span>angle30)<span class="op">/</span><span class="dv">2</span>],</span>
<span id="cb183-4"><a href="#cb183-4" aria-hidden="true" tabindex="-1"></a>               [np.sin(<span class="dv">2</span><span class="op">*</span>angle30)<span class="op">/</span><span class="dv">2</span>, np.sin(angle30)<span class="op">**</span><span class="dv">2</span>]</span>
<span id="cb183-5"><a href="#cb183-5" aria-hidden="true" tabindex="-1"></a>         ])</span>
<span id="cb183-6"><a href="#cb183-6" aria-hidden="true" tabindex="-1"></a>plot_transformation(P, F_project_30.dot(P), <span class="st">"$P$"</span>, <span class="st">"$F_{project\_30} \cdot P$"</span>,</span>
<span id="cb183-7"><a href="#cb183-7" aria-hidden="true" tabindex="-1"></a>                    axis<span class="op">=</span>[<span class="dv">0</span>, <span class="dv">6</span>, <span class="op">-</span><span class="dv">1</span>, <span class="dv">4</span>])</span>
<span id="cb183-8"><a href="#cb183-8" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="math_linear_algebra_files/figure-html/cell-107-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>But this time, due to floating point rounding errors, NumPy manages to calculate an inverse (notice how large the elements are, though):</p>
<div class="cell" data-execution_count="108">
<div class="sourceCode cell-code" id="cb184"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb184-1"><a href="#cb184-1" aria-hidden="true" tabindex="-1"></a>LA.inv(F_project_30)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="108">
<pre><code>array([[  1.20095990e+16,  -2.08012357e+16],
       [ -2.08012357e+16,   3.60287970e+16]])</code></pre>
</div>
</div>
<p>As you might expect, the dot product of a matrix by its inverse results in the identity matrix:</p>
<p><span class="math inline">\(M \cdot M^{-1} = M^{-1} \cdot M = I\)</span></p>
<p>This makes sense since doing a linear transformation followed by the inverse transformation results in no change at all.</p>
<div class="cell" data-execution_count="109">
<div class="sourceCode cell-code" id="cb186"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb186-1"><a href="#cb186-1" aria-hidden="true" tabindex="-1"></a>F_shear.dot(LA.inv(F_shear))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="109">
<pre><code>array([[ 1.,  0.],
       [ 0.,  1.]])</code></pre>
</div>
</div>
<p>Another way to express this is that the inverse of the inverse of a matrix <span class="math inline">\(M\)</span> is <span class="math inline">\(M\)</span> itself:</p>
<p><span class="math inline">\(((M)^{-1})^{-1} = M\)</span></p>
<div class="cell" data-execution_count="110">
<div class="sourceCode cell-code" id="cb188"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb188-1"><a href="#cb188-1" aria-hidden="true" tabindex="-1"></a>LA.inv(LA.inv(F_shear))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="110">
<pre><code>array([[ 1. ,  1.5],
       [ 0. ,  1. ]])</code></pre>
</div>
</div>
<p>Also, the inverse of scaling by a factor of <span class="math inline">\(\lambda\)</span> is of course scaling by a factor or <span class="math inline">\(\frac{1}{\lambda}\)</span>:</p>
<p>$ (M)^{-1} = M^{-1}$</p>
<p>Once you understand the geometric interpretation of matrices as linear transformations, most of these properties seem fairly intuitive.</p>
<p>A matrix that is its own inverse is called an <strong>involution</strong>. The simplest examples are reflection matrices, or a rotation by 180°, but there are also more complex involutions, for example imagine a transformation that squeezes horizontally, then reflects over the vertical axis and finally rotates by 90° clockwise. Pick up a napkin and try doing that twice: you will end up in the original position. Here is the corresponding involutory matrix:</p>
<div class="cell" data-execution_count="111">
<div class="sourceCode cell-code" id="cb190"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb190-1"><a href="#cb190-1" aria-hidden="true" tabindex="-1"></a>F_involution  <span class="op">=</span> np.array([</span>
<span id="cb190-2"><a href="#cb190-2" aria-hidden="true" tabindex="-1"></a>        [<span class="dv">0</span>, <span class="op">-</span><span class="dv">2</span>],</span>
<span id="cb190-3"><a href="#cb190-3" aria-hidden="true" tabindex="-1"></a>        [<span class="op">-</span><span class="dv">1</span><span class="op">/</span><span class="dv">2</span>, <span class="dv">0</span>]</span>
<span id="cb190-4"><a href="#cb190-4" aria-hidden="true" tabindex="-1"></a>    ])</span>
<span id="cb190-5"><a href="#cb190-5" aria-hidden="true" tabindex="-1"></a>plot_transformation(P, F_involution.dot(P), <span class="st">"$P$"</span>, <span class="st">"$F_</span><span class="sc">{involution}</span><span class="st"> \cdot P$"</span>,</span>
<span id="cb190-6"><a href="#cb190-6" aria-hidden="true" tabindex="-1"></a>                    axis<span class="op">=</span>[<span class="op">-</span><span class="dv">8</span>, <span class="dv">5</span>, <span class="op">-</span><span class="dv">4</span>, <span class="dv">4</span>])</span>
<span id="cb190-7"><a href="#cb190-7" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="math_linear_algebra_files/figure-html/cell-111-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>Finally, a square matrix <span class="math inline">\(H\)</span> whose inverse is its own transpose is an <strong>orthogonal matrix</strong>:</p>
<p><span class="math inline">\(H^{-1} = H^T\)</span></p>
<p>Therefore:</p>
<p><span class="math inline">\(H \cdot H^T = H^T \cdot H = I\)</span></p>
<p>It corresponds to a transformation that preserves distances, such as rotations and reflections, and combinations of these, but not rescaling, shearing or squeezing. Let’s check that <span class="math inline">\(F_{reflect}\)</span> is indeed orthogonal:</p>
<div class="cell" data-execution_count="112">
<div class="sourceCode cell-code" id="cb191"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb191-1"><a href="#cb191-1" aria-hidden="true" tabindex="-1"></a>F_reflect.dot(F_reflect.T)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="112">
<pre><code>array([[1, 0],
       [0, 1]])</code></pre>
</div>
</div>
</section>
<section id="determinant" class="level2">
<h2 class="anchored" data-anchor-id="determinant">Determinant</h2>
<p>The determinant of a square matrix <span class="math inline">\(M\)</span>, noted <span class="math inline">\(\det(M)\)</span> or <span class="math inline">\(\det M\)</span> or <span class="math inline">\(|M|\)</span> is a value that can be calculated from its elements <span class="math inline">\((M_{i,j})\)</span> using various equivalent methods. One of the simplest methods is this recursive approach:</p>
<p><span class="math inline">\(|M| = M_{1,1}\times|M^{(1,1)}| - M_{1,2}\times|M^{(1,2)}| + M_{1,3}\times|M^{(1,3)}| - M_{1,4}\times|M^{(1,4)}| + \cdots ± M_{1,n}\times|M^{(1,n)}|\)</span></p>
<ul>
<li>Where <span class="math inline">\(M^{(i,j)}\)</span> is the matrix <span class="math inline">\(M\)</span> without row <span class="math inline">\(i\)</span> and column <span class="math inline">\(j\)</span>.</li>
</ul>
<p>For example, let’s calculate the determinant of the following <span class="math inline">\(3 \times 3\)</span> matrix:</p>
<p><span class="math inline">\(M = \begin{bmatrix}  1 &amp; 2 &amp; 3 \\  4 &amp; 5 &amp; 6 \\  7 &amp; 8 &amp; 0 \end{bmatrix}\)</span></p>
<p>Using the method above, we get:</p>
<p><span class="math inline">\(|M| = 1 \times \left | \begin{bmatrix} 5 &amp; 6 \\ 8 &amp; 0 \end{bmatrix} \right |  - 2 \times \left | \begin{bmatrix} 4 &amp; 6 \\ 7 &amp; 0 \end{bmatrix} \right |  + 3 \times \left | \begin{bmatrix} 4 &amp; 5 \\ 7 &amp; 8 \end{bmatrix} \right |\)</span></p>
<p>Now we need to compute the determinant of each of these <span class="math inline">\(2 \times 2\)</span> matrices (these determinants are called <strong>minors</strong>):</p>
<p><span class="math inline">\(\left | \begin{bmatrix} 5 &amp; 6 \\ 8 &amp; 0 \end{bmatrix} \right | = 5 \times 0 - 6 \times 8 = -48\)</span></p>
<p><span class="math inline">\(\left | \begin{bmatrix} 4 &amp; 6 \\ 7 &amp; 0 \end{bmatrix} \right | = 4 \times 0 - 6 \times 7 = -42\)</span></p>
<p><span class="math inline">\(\left | \begin{bmatrix} 4 &amp; 5 \\ 7 &amp; 8 \end{bmatrix} \right | = 4 \times 8 - 5 \times 7 = -3\)</span></p>
<p>Now we can calculate the final result:</p>
<p><span class="math inline">\(|M| = 1 \times (-48) - 2 \times (-42) + 3 \times (-3) = 27\)</span></p>
<p>To get the determinant of a matrix, you can call NumPy’s <code>det</code> function in the <code>numpy.linalg</code> module:</p>
<div class="cell" data-execution_count="113">
<div class="sourceCode cell-code" id="cb193"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb193-1"><a href="#cb193-1" aria-hidden="true" tabindex="-1"></a>M <span class="op">=</span> np.array([</span>
<span id="cb193-2"><a href="#cb193-2" aria-hidden="true" tabindex="-1"></a>        [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>],</span>
<span id="cb193-3"><a href="#cb193-3" aria-hidden="true" tabindex="-1"></a>        [<span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>],</span>
<span id="cb193-4"><a href="#cb193-4" aria-hidden="true" tabindex="-1"></a>        [<span class="dv">7</span>, <span class="dv">8</span>, <span class="dv">0</span>]</span>
<span id="cb193-5"><a href="#cb193-5" aria-hidden="true" tabindex="-1"></a>    ])</span>
<span id="cb193-6"><a href="#cb193-6" aria-hidden="true" tabindex="-1"></a>LA.det(M)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="113">
<pre><code>27.0</code></pre>
</div>
</div>
<p>One of the main uses of the determinant is to <em>determine</em> whether a square matrix can be inversed or not: if the determinant is equal to 0, then the matrix <em>cannot</em> be inversed (it is a singular matrix), and if the determinant is not 0, then it <em>can</em> be inversed.</p>
<p>For example, let’s compute the determinant for the <span class="math inline">\(F_{project}\)</span>, <span class="math inline">\(F_{project\_30}\)</span> and <span class="math inline">\(F_{shear}\)</span> matrices that we defined earlier:</p>
<div class="cell" data-execution_count="114">
<div class="sourceCode cell-code" id="cb195"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb195-1"><a href="#cb195-1" aria-hidden="true" tabindex="-1"></a>LA.det(F_project)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="114">
<pre><code>0.0</code></pre>
</div>
</div>
<p>That’s right, <span class="math inline">\(F_{project}\)</span> is singular, as we saw earlier.</p>
<div class="cell" data-execution_count="115">
<div class="sourceCode cell-code" id="cb197"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb197-1"><a href="#cb197-1" aria-hidden="true" tabindex="-1"></a>LA.det(F_project_30)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="115">
<pre><code>2.0816681711721642e-17</code></pre>
</div>
</div>
<p>This determinant is suspiciously close to 0: it really should be 0, but it’s not due to tiny floating point errors. The matrix is actually singular.</p>
<div class="cell" data-execution_count="116">
<div class="sourceCode cell-code" id="cb199"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb199-1"><a href="#cb199-1" aria-hidden="true" tabindex="-1"></a>LA.det(F_shear)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="116">
<pre><code>1.0</code></pre>
</div>
</div>
<p>Perfect! This matrix <em>can</em> be inversed as we saw earlier. Wow, math really works!</p>
<p>The determinant can also be used to measure how much a linear transformation affects surface areas: for example, the projection matrices <span class="math inline">\(F_{project}\)</span> and <span class="math inline">\(F_{project\_30}\)</span> completely flatten the polygon <span class="math inline">\(P\)</span>, until its area is zero. This is why the determinant of these matrices is 0. The shear mapping modified the shape of the polygon, but it did not affect its surface area, which is why the determinant is 1. You can try computing the determinant of a rotation matrix, and you should also find 1. What about a scaling matrix? Let’s see:</p>
<div class="cell" data-execution_count="117">
<div class="sourceCode cell-code" id="cb201"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb201-1"><a href="#cb201-1" aria-hidden="true" tabindex="-1"></a>F_scale <span class="op">=</span> np.array([</span>
<span id="cb201-2"><a href="#cb201-2" aria-hidden="true" tabindex="-1"></a>        [<span class="fl">0.5</span>, <span class="dv">0</span>],</span>
<span id="cb201-3"><a href="#cb201-3" aria-hidden="true" tabindex="-1"></a>        [<span class="dv">0</span>, <span class="fl">0.5</span>]</span>
<span id="cb201-4"><a href="#cb201-4" aria-hidden="true" tabindex="-1"></a>    ])</span>
<span id="cb201-5"><a href="#cb201-5" aria-hidden="true" tabindex="-1"></a>plot_transformation(P, F_scale.dot(P), <span class="st">"$P$"</span>, <span class="st">"$F_</span><span class="sc">{scale}</span><span class="st"> \cdot P$"</span>,</span>
<span id="cb201-6"><a href="#cb201-6" aria-hidden="true" tabindex="-1"></a>                    axis<span class="op">=</span>[<span class="dv">0</span>, <span class="dv">6</span>, <span class="op">-</span><span class="dv">1</span>, <span class="dv">4</span>])</span>
<span id="cb201-7"><a href="#cb201-7" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="math_linear_algebra_files/figure-html/cell-117-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>We rescaled the polygon by a factor of 1/2 on both vertical and horizontal axes so the surface area of the resulting polygon is 1/4<span class="math inline">\(^{th}\)</span> of the original polygon. Let’s compute the determinant and check that:</p>
<div class="cell" data-execution_count="118">
<div class="sourceCode cell-code" id="cb202"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb202-1"><a href="#cb202-1" aria-hidden="true" tabindex="-1"></a>LA.det(F_scale)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="118">
<pre><code>0.25</code></pre>
</div>
</div>
<p>Correct!</p>
<p>The determinant can actually be negative, when the transformation results in a “flipped over” version of the original polygon (eg. a left hand glove becomes a right hand glove). For example, the determinant of the <code>F_reflect</code> matrix is -1 because the surface area is preserved but the polygon gets flipped over:</p>
<div class="cell" data-execution_count="119">
<div class="sourceCode cell-code" id="cb204"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb204-1"><a href="#cb204-1" aria-hidden="true" tabindex="-1"></a>LA.det(F_reflect)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="119">
<pre><code>-1.0</code></pre>
</div>
</div>
</section>
<section id="composing-linear-transformations" class="level2">
<h2 class="anchored" data-anchor-id="composing-linear-transformations">Composing linear transformations</h2>
<p>Several linear transformations can be chained simply by performing multiple dot products in a row. For example, to perform a squeeze mapping followed by a shear mapping, just write:</p>
<div class="cell" data-execution_count="120">
<div class="sourceCode cell-code" id="cb206"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb206-1"><a href="#cb206-1" aria-hidden="true" tabindex="-1"></a>P_squeezed_then_sheared <span class="op">=</span> F_shear.dot(F_squeeze.dot(P))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Since the dot product is associative, the following code is equivalent:</p>
<div class="cell" data-execution_count="121">
<div class="sourceCode cell-code" id="cb207"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb207-1"><a href="#cb207-1" aria-hidden="true" tabindex="-1"></a>P_squeezed_then_sheared <span class="op">=</span> (F_shear.dot(F_squeeze)).dot(P)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Note that the order of the transformations is the reverse of the dot product order.</p>
<p>If we are going to perform this composition of linear transformations more than once, we might as well save the composition matrix like this:</p>
<div class="cell" data-jupyter="{&quot;outputs_hidden&quot;:true}" data-execution_count="122">
<div class="sourceCode cell-code" id="cb208"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb208-1"><a href="#cb208-1" aria-hidden="true" tabindex="-1"></a>F_squeeze_then_shear <span class="op">=</span> F_shear.dot(F_squeeze)</span>
<span id="cb208-2"><a href="#cb208-2" aria-hidden="true" tabindex="-1"></a>P_squeezed_then_sheared <span class="op">=</span> F_squeeze_then_shear.dot(P)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>From now on we can perform both transformations in just one dot product, which can lead to a very significant performance boost.</p>
<p>What if you want to perform the inverse of this double transformation? Well, if you squeezed and then you sheared, and you want to undo what you have done, it should be obvious that you should unshear first and then unsqueeze. In more mathematical terms, given two invertible (aka nonsingular) matrices <span class="math inline">\(Q\)</span> and <span class="math inline">\(R\)</span>:</p>
<p><span class="math inline">\((Q \cdot R)^{-1} = R^{-1} \cdot Q^{-1}\)</span></p>
<p>And in NumPy:</p>
<div class="cell" data-execution_count="123">
<div class="sourceCode cell-code" id="cb209"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb209-1"><a href="#cb209-1" aria-hidden="true" tabindex="-1"></a>LA.inv(F_shear.dot(F_squeeze)) <span class="op">==</span> LA.inv(F_squeeze).dot(LA.inv(F_shear))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="123">
<pre><code>array([[ True,  True],
       [ True,  True]], dtype=bool)</code></pre>
</div>
</div>
</section>
<section id="singular-value-decomposition" class="level2">
<h2 class="anchored" data-anchor-id="singular-value-decomposition">Singular Value Decomposition</h2>
<p>It turns out that any <span class="math inline">\(m \times n\)</span> matrix <span class="math inline">\(M\)</span> can be decomposed into the dot product of three simple matrices: * a rotation matrix <span class="math inline">\(U\)</span> (an <span class="math inline">\(m \times m\)</span> orthogonal matrix) * a scaling &amp; projecting matrix <span class="math inline">\(\Sigma\)</span> (an <span class="math inline">\(m \times n\)</span> diagonal matrix) * and another rotation matrix <span class="math inline">\(V^T\)</span> (an <span class="math inline">\(n \times n\)</span> orthogonal matrix)</p>
<p><span class="math inline">\(M = U \cdot \Sigma \cdot V^{T}\)</span></p>
<p>For example, let’s decompose the shear transformation:</p>
<div class="cell" data-execution_count="124">
<div class="sourceCode cell-code" id="cb211"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb211-1"><a href="#cb211-1" aria-hidden="true" tabindex="-1"></a>U, S_diag, V_T <span class="op">=</span> LA.svd(F_shear) <span class="co"># note: in python 3 you can rename S_diag to Σ_diag</span></span>
<span id="cb211-2"><a href="#cb211-2" aria-hidden="true" tabindex="-1"></a>U</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="124">
<pre><code>array([[ 0.89442719, -0.4472136 ],
       [ 0.4472136 ,  0.89442719]])</code></pre>
</div>
</div>
<div class="cell" data-execution_count="125">
<div class="sourceCode cell-code" id="cb213"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb213-1"><a href="#cb213-1" aria-hidden="true" tabindex="-1"></a>S_diag</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="125">
<pre><code>array([ 2. ,  0.5])</code></pre>
</div>
</div>
<p>Note that this is just a 1D array containing the diagonal values of Σ. To get the actual matrix Σ, we can use NumPy’s <code>diag</code> function:</p>
<div class="cell" data-execution_count="126">
<div class="sourceCode cell-code" id="cb215"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb215-1"><a href="#cb215-1" aria-hidden="true" tabindex="-1"></a>S <span class="op">=</span> np.diag(S_diag)</span>
<span id="cb215-2"><a href="#cb215-2" aria-hidden="true" tabindex="-1"></a>S</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="126">
<pre><code>array([[ 2. ,  0. ],
       [ 0. ,  0.5]])</code></pre>
</div>
</div>
<p>Now let’s check that <span class="math inline">\(U \cdot \Sigma \cdot V^T\)</span> is indeed equal to <code>F_shear</code>:</p>
<div class="cell" data-execution_count="127">
<div class="sourceCode cell-code" id="cb217"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb217-1"><a href="#cb217-1" aria-hidden="true" tabindex="-1"></a>U.dot(np.diag(S_diag)).dot(V_T)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="127">
<pre><code>array([[ 1. ,  1.5],
       [ 0. ,  1. ]])</code></pre>
</div>
</div>
<div class="cell" data-execution_count="128">
<div class="sourceCode cell-code" id="cb219"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb219-1"><a href="#cb219-1" aria-hidden="true" tabindex="-1"></a>F_shear</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="128">
<pre><code>array([[ 1. ,  1.5],
       [ 0. ,  1. ]])</code></pre>
</div>
</div>
<p>It worked like a charm. Let’s apply these transformations one by one (in reverse order) on the unit square to understand what’s going on. First, let’s apply the first rotation <span class="math inline">\(V^T\)</span>:</p>
<div class="cell" data-execution_count="129">
<div class="sourceCode cell-code" id="cb221"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb221-1"><a href="#cb221-1" aria-hidden="true" tabindex="-1"></a>plot_transformation(Square, V_T.dot(Square), <span class="st">"$Square$"</span>, <span class="st">"$V^T \cdot Square$"</span>,</span>
<span id="cb221-2"><a href="#cb221-2" aria-hidden="true" tabindex="-1"></a>                    axis<span class="op">=</span>[<span class="op">-</span><span class="fl">0.5</span>, <span class="fl">3.5</span> , <span class="op">-</span><span class="fl">1.5</span>, <span class="fl">1.5</span>])</span>
<span id="cb221-3"><a href="#cb221-3" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="math_linear_algebra_files/figure-html/cell-129-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>Now let’s rescale along the vertical and horizontal axes using <span class="math inline">\(\Sigma\)</span>:</p>
<div class="cell" data-execution_count="130">
<div class="sourceCode cell-code" id="cb222"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb222-1"><a href="#cb222-1" aria-hidden="true" tabindex="-1"></a>plot_transformation(V_T.dot(Square), S.dot(V_T).dot(Square), <span class="st">"$V^T \cdot Square$"</span>, <span class="st">"$\Sigma \cdot V^T \cdot Square$"</span>,</span>
<span id="cb222-2"><a href="#cb222-2" aria-hidden="true" tabindex="-1"></a>                    axis<span class="op">=</span>[<span class="op">-</span><span class="fl">0.5</span>, <span class="fl">3.5</span> , <span class="op">-</span><span class="fl">1.5</span>, <span class="fl">1.5</span>])</span>
<span id="cb222-3"><a href="#cb222-3" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="math_linear_algebra_files/figure-html/cell-130-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>Finally, we apply the second rotation <span class="math inline">\(U\)</span>:</p>
<div class="cell" data-execution_count="131">
<div class="sourceCode cell-code" id="cb223"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb223-1"><a href="#cb223-1" aria-hidden="true" tabindex="-1"></a>plot_transformation(S.dot(V_T).dot(Square), U.dot(S).dot(V_T).dot(Square),<span class="st">"$\Sigma \cdot V^T \cdot Square$"</span>, <span class="st">"$U \cdot \Sigma \cdot V^T \cdot Square$"</span>,</span>
<span id="cb223-2"><a href="#cb223-2" aria-hidden="true" tabindex="-1"></a>                    axis<span class="op">=</span>[<span class="op">-</span><span class="fl">0.5</span>, <span class="fl">3.5</span> , <span class="op">-</span><span class="fl">1.5</span>, <span class="fl">1.5</span>])</span>
<span id="cb223-3"><a href="#cb223-3" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="math_linear_algebra_files/figure-html/cell-131-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>And we can see that the result is indeed a shear mapping of the original unit square.</p>
</section>
<section id="eigenvectors-and-eigenvalues" class="level2">
<h2 class="anchored" data-anchor-id="eigenvectors-and-eigenvalues">Eigenvectors and eigenvalues</h2>
<p>An <strong>eigenvector</strong> of a square matrix <span class="math inline">\(M\)</span> (also called a <strong>characteristic vector</strong>) is a non-zero vector that remains on the same line after transformation by the linear transformation associated with <span class="math inline">\(M\)</span>. A more formal definition is any vector <span class="math inline">\(v\)</span> such that:</p>
<p><span class="math inline">\(M \cdot v = \lambda \times v\)</span></p>
<p>Where <span class="math inline">\(\lambda\)</span> is a scalar value called the <strong>eigenvalue</strong> associated to the vector <span class="math inline">\(v\)</span>.</p>
<p>For example, any horizontal vector remains horizontal after applying the shear mapping (as you can see on the image above), so it is an eigenvector of <span class="math inline">\(M\)</span>. A vertical vector ends up tilted to the right, so vertical vectors are <em>NOT</em> eigenvectors of <span class="math inline">\(M\)</span>.</p>
<p>If we look at the squeeze mapping, we find that any horizontal or vertical vector keeps its direction (although its length changes), so all horizontal and vertical vectors are eigenvectors of <span class="math inline">\(F_{squeeze}\)</span>.</p>
<p>However, rotation matrices have no eigenvectors at all (except if the rotation angle is 0° or 180°, in which case all non-zero vectors are eigenvectors).</p>
<p>NumPy’s <code>eig</code> function returns the list of unit eigenvectors and their corresponding eigenvalues for any square matrix. Let’s look at the eigenvectors and eigenvalues of the squeeze mapping matrix <span class="math inline">\(F_{squeeze}\)</span>:</p>
<div class="cell" data-execution_count="132">
<div class="sourceCode cell-code" id="cb224"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb224-1"><a href="#cb224-1" aria-hidden="true" tabindex="-1"></a>eigenvalues, eigenvectors <span class="op">=</span> LA.eig(F_squeeze)</span>
<span id="cb224-2"><a href="#cb224-2" aria-hidden="true" tabindex="-1"></a>eigenvalues <span class="co"># [λ0, λ1, …]</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="132">
<pre><code>array([ 1.4       ,  0.71428571])</code></pre>
</div>
</div>
<div class="cell" data-execution_count="133">
<div class="sourceCode cell-code" id="cb226"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb226-1"><a href="#cb226-1" aria-hidden="true" tabindex="-1"></a>eigenvectors <span class="co"># [v0, v1, …]</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="133">
<pre><code>array([[ 1.,  0.],
       [ 0.,  1.]])</code></pre>
</div>
</div>
<p>Indeed the horizontal vectors are stretched by a factor of 1.4, and the vertical vectors are shrunk by a factor of 1/1.4=0.714…, so far so good. Let’s look at the shear mapping matrix <span class="math inline">\(F_{shear}\)</span>:</p>
<div class="cell" data-execution_count="134">
<div class="sourceCode cell-code" id="cb228"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb228-1"><a href="#cb228-1" aria-hidden="true" tabindex="-1"></a>eigenvalues2, eigenvectors2 <span class="op">=</span> LA.eig(F_shear)</span>
<span id="cb228-2"><a href="#cb228-2" aria-hidden="true" tabindex="-1"></a>eigenvalues2 <span class="co"># [λ0, λ1, …]</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="134">
<pre><code>array([ 1.,  1.])</code></pre>
</div>
</div>
<div class="cell" data-execution_count="135">
<div class="sourceCode cell-code" id="cb230"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb230-1"><a href="#cb230-1" aria-hidden="true" tabindex="-1"></a>eigenvectors2 <span class="co"># [v0, v1, …]</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="135">
<pre><code>array([[  1.00000000e+00,  -1.00000000e+00],
       [  0.00000000e+00,   1.48029737e-16]])</code></pre>
</div>
</div>
<p>Wait, what!? We expected just one unit eigenvector, not two. The second vector is almost equal to <span class="math inline">\(\begin{pmatrix}-1 \\ 0 \end{pmatrix}\)</span>, which is on the same line as the first vector <span class="math inline">\(\begin{pmatrix}1 \\ 0 \end{pmatrix}\)</span>. This is due to floating point errors. We can safely ignore vectors that are (almost) colinear (ie. on the same line).</p>
</section>
<section id="trace" class="level2">
<h2 class="anchored" data-anchor-id="trace">Trace</h2>
<p>The trace of a square matrix <span class="math inline">\(M\)</span>, noted <span class="math inline">\(tr(M)\)</span> is the sum of the values on its main diagonal. For example:</p>
<div class="cell" data-execution_count="136">
<div class="sourceCode cell-code" id="cb232"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb232-1"><a href="#cb232-1" aria-hidden="true" tabindex="-1"></a>D <span class="op">=</span> np.array([</span>
<span id="cb232-2"><a href="#cb232-2" aria-hidden="true" tabindex="-1"></a>        [<span class="dv">100</span>, <span class="dv">200</span>, <span class="dv">300</span>],</span>
<span id="cb232-3"><a href="#cb232-3" aria-hidden="true" tabindex="-1"></a>        [ <span class="dv">10</span>,  <span class="dv">20</span>,  <span class="dv">30</span>],</span>
<span id="cb232-4"><a href="#cb232-4" aria-hidden="true" tabindex="-1"></a>        [  <span class="dv">1</span>,   <span class="dv">2</span>,   <span class="dv">3</span>],</span>
<span id="cb232-5"><a href="#cb232-5" aria-hidden="true" tabindex="-1"></a>    ])</span>
<span id="cb232-6"><a href="#cb232-6" aria-hidden="true" tabindex="-1"></a>np.trace(D)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="136">
<pre><code>123</code></pre>
</div>
</div>
<p>The trace does not have a simple geometric interpretation (in general), but it has a number of properties that make it useful in many areas: * <span class="math inline">\(tr(A + B) = tr(A) + tr(B)\)</span> * <span class="math inline">\(tr(A \cdot B) = tr(B \cdot A)\)</span> * <span class="math inline">\(tr(A \cdot B \cdot \cdots \cdot Y \cdot Z) = tr(Z \cdot A \cdot B \cdot \cdots \cdot Y)\)</span> * <span class="math inline">\(tr(A^T \cdot B) = tr(A \cdot B^T) = tr(B^T \cdot A) = tr(B \cdot A^T) = \sum_{i,j}X_{i,j} \times Y_{i,j}\)</span> * …</p>
<p>It does, however, have a useful geometric interpretation in the case of projection matrices (such as <span class="math inline">\(F_{project}\)</span> that we discussed earlier): it corresponds to the number of dimensions after projection. For example:</p>
<div class="cell" data-execution_count="137">
<div class="sourceCode cell-code" id="cb234"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb234-1"><a href="#cb234-1" aria-hidden="true" tabindex="-1"></a>np.trace(F_project)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="137">
<pre><code>1</code></pre>
</div>
</div>
</section>
</section>
<section id="what-next" class="level1">
<h1>What next?</h1>
<p>This concludes this introduction to Linear Algebra. Although these basics cover most of what you will need to know for Machine Learning, if you wish to go deeper into this topic there are many options available: Linear Algebra <a href="http://linear.axler.net/">books</a>, <a href="https://www.khanacademy.org/math/linear-algebra">Khan Academy</a> lessons, or just <a href="https://en.wikipedia.org/wiki/Linear_algebra">Wikipedia</a> pages.</p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>