<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Jasmine Kobayashi">

<title>HW3: Part A - Reasoning</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="PartA-Reasoning_files/libs/clipboard/clipboard.min.js"></script>
<script src="PartA-Reasoning_files/libs/quarto-html/quarto.js"></script>
<script src="PartA-Reasoning_files/libs/quarto-html/popper.min.js"></script>
<script src="PartA-Reasoning_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="PartA-Reasoning_files/libs/quarto-html/anchor.min.js"></script>
<link href="PartA-Reasoning_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="PartA-Reasoning_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="PartA-Reasoning_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="PartA-Reasoning_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="PartA-Reasoning_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#question-1" id="toc-question-1" class="nav-link active" data-scroll-target="#question-1">Question 1</a></li>
  <li><a href="#question-2" id="toc-question-2" class="nav-link" data-scroll-target="#question-2">Question 2</a></li>
  <li><a href="#question-3" id="toc-question-3" class="nav-link" data-scroll-target="#question-3">Question 3</a>
  <ul class="collapse">
  <li><a href="#plot1" id="toc-plot1" class="nav-link" data-scroll-target="#plot1">Plot1</a></li>
  <li><a href="#plots2" id="toc-plots2" class="nav-link" data-scroll-target="#plots2">Plot(s)2</a></li>
  </ul></li>
  </ul>
</nav>
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">HW3: Part A - Reasoning</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Jasmine Kobayashi </p>
          </div>
  </div>
    
  
    
  </div>
  

</header>

<p>Answer these questions as you were asked during an interview: Don’t talk too less, and don’t talk too much!</p>
<section id="question-1" class="level1">
<h1>Question 1</h1>
<p><strong>What do you mean by a normal distribution of data? What happens when the data is not normally distributed? Explain with an example.</strong></p>
<p>Normal data distribution implies that the mean, median, and mode of a data set are all the same value. A histogram of a normally distributed dataset resembles a “bell shape” (thus also commonly associated with the term “bell curve”) where the value counts peak at the value in the center of the range, and the rest symmetrically taper as you approach the min and max values.</p>
<p>When a set of data is not normally distributed, that means that most of the data is skewed toward values other than the center value.</p>
</section>
<section id="question-2" class="level1">
<h1>Question 2</h1>
<p><strong>How is a quantile-quantile plot different from a quantile plot? Illustrate with an example.</strong></p>
<p>A quantile plot displays the quantile information from the distribution of a single random variable (univariate distribution). So, specifically speaking, the x-axis would indicate what the f-values are the y-axis is the values that exist in the data for the random variable.</p>
<p>A quantile-quantile plot (aka q-q plot) plots the quantiles of one random variable against the quantiles of another.</p>
<p>Plots the quantiles of one univariate distribution against the corresponding quantiles of another.</p>
</section>
<section id="question-3" class="level1">
<h1>Question 3</h1>
<p><strong>Identify the plots below and explain the questions that follow</strong></p>
<section id="plot1" class="level2">
<h2 class="anchored" data-anchor-id="plot1">Plot1</h2>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="plot1.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">plot1.png</figcaption>
</figure>
</div>
<ul>
<li><strong>What is the plot above? (Scatter, Strip, Swarm)</strong></li>
<li><strong>What can you infer from the plot?</strong></li>
<li><strong>How is it different from the other two plots below?</strong></li>
</ul>
<p>Because the points don’t line up in a single line for each category, this doesn’t appear to be a categorized scatter plot. Strip and swarm are pretty similar to my understanding, but because there is minimal overlap between the clustered points, I want to say this is a swarm plot.</p>
<p>From this plot, I think I can infer that the “BigMac Index” (which I have never heard of until this assignment and now know is a measurement of purchasing power between different countries) is similarly distributed for the three given population types. The ‘stable’ and ‘constrictive’ population types are the only two with some outlying extremes, and the ‘constrictive’ population type has the largest range of extremes. And all three population types seem to cluster within the 2-5 index range.</p>
<p>This type of plot differs from the two bottom plots by giving a visual representation of the exact values of each and every point. The information this type of plot gives compared to the bottom two is quite different. The visualization of each individual point gives you an accurate depiction of the exact values the points seem to cluster around; however, it also leaves the interpreter to visually guesstimate the statistical values like averages and quantiles. Whereas the information in the two plots below provides a more exact visualization of the statistics of the data (quantiles, etc.) but thus a general summary of the data points (not any idea of how many points there are, etc.).</p>
</section>
<section id="plots2" class="level2">
<h2 class="anchored" data-anchor-id="plots2">Plot(s)2</h2>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="plot2and3.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">plot2and3.png</figcaption>
</figure>
</div>
<ul>
<li><strong>What are the above two plots?</strong></li>
<li><strong>What can you infer?</strong></li>
<li><strong>Explain which one of the above two plots is better than the other with the proper justification.</strong></li>
</ul>
<p>The two plots from left to right are violin plots and box plots, respectively.</p>
<p>I can infer that whatever parameter “3” is supposed to represent, it has the largest range of values compared to the other two. “3” is also the only one the box plot considered to have any outliers (but even if you didn’t consider those, the difference between the relative maximum and relative minimum is still the largest of the three). However, “3” also seems to have the most normalized distribution of values compared to the other two. All three ‘categories’ have similar, if not the exact same, first, second, and third quartile values. “1” and “2” have similar or same (absolute) maximum and minimum.</p>
<p>Well, I would be reluctant to say one is “better” than the other because I find the use of both of them side-to-side like this to be the most informative (like the “outlier” minimum in “3”). However, if I HAD to pick one plot, I would likely choose the violin plot because it gives the same information as the box plot PLUS a bit more information regarding the distribution shape across each range. Specifically speaking, we can see how “1” and “2” differ in the violin plot.</p>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>